# Java Programming Guide {#java-programming-guide}
## Packages {#packages}
Packages in Java are namespaces that organize related classes and interfaces. They provide a way to manage code and prevent naming conflicts, particularly in large projects.
### Purpose: {#purpose:}
- **Organization**: Grouping related classes for better code structure.
- **Naming Conflicts**: Prevents classes with the same name from colliding.
- **Access Control**: Offers a level of access control to members within a package.
### Defining a Package {#defining-a-package}
Use the `package` keyword at the beginning of a Java source file. The package name should follow a reversed domain name convention (e.g., `com.example.myapp`).
```java
package com.example.myapp;
public class MyClass {
// Class implementation
}
```
### Importing Packages {#importing-packages}
To use classes from other packages, you need to import them using the `import` keyword. You can import a specific class or all classes within a package using a wildcard (*).
```java
import com.example.myapp.MyClass; // Import a single class
// Or
import com.example.myapp.*; // Import all classes in the package
```
### Default Package {#default-package}
Classes without an explicit package declaration belong to the default package. Using the default package is generally discouraged for larger projects as it can lead to naming conflicts and organizational issues.
### Package Structure {#package-structure}
The package structure should mirror the directory structure of your source code. For example, if your package is `com.example.myapp`, your class `MyClass` should reside in a directory structure `com/example/myapp/MyClass.java`.
## Variables {#variables}
Variables are named storage locations that hold data values. In Java, every variable has a specific data type that determines the kind of data it can store.
### Data Types {#data-types}
Java has two main categories of data types: primitive and reference.
#### Primitive Data Types {#primitive-data-types}
These store simple values directly.
- **byte**: 8-bit integer
- **short**: 16-bit integer
- **int**: 32-bit integer
- **long**: 64-bit integer
- **float**: 32-bit floating-point number
- **double**: 64-bit floating-point number
- **boolean**: true or false
- **char**: Single Unicode character
#### Reference Data Types {#reference-data-types}
These store the memory address (reference) of an object. Examples include:
- String
- Arrays
- Classes
- Interfaces
### Variable Declaration and Initialization {#variable-declaration-and-initialization}
Before using a variable, you must declare it by specifying its data type and name. You can optionally initialize the variable with a value at the time of declaration.
```java
int age; // Declaration
age = 30; // Initialization
// Or combined:
int age = 30; // Declaration and initialization
String name = "John Doe"; // Declaration and initialization
```
### Variable Scope {#variable-scope}
The scope of a variable determines where in the code it can be accessed. Variables can have different scopes:
- **Local Variables**: Declared within a method or block of code. They are only accessible within that method or block.
- **Instance Variables**: Declared within a class but outside any method. They are associated with each instance (object) of the class.
- **Static Variables (Class Variables)**: Declared with the `static` keyword. They are shared by all instances of the class and are associated with the class itself.
### Naming Conventions {#naming-conventions}
Variable names should be descriptive and follow these conventions:
- Start with a lowercase letter.
- Use camelCase for multi-word names (e.g., `firstName`).
- Avoid using reserved keywords.
## Classes {#classes}
Classes are blueprints for creating objects. They define the attributes (data) and behaviors (methods) that objects of that class will have.
### Class Definition {#class-definition}
Use the `class` keyword to define a class.
```java
public class Dog {
// Attributes (instance variables)
String breed;
int age;
// Methods
public void bark() {
System.out.println("Woof!");
}
}
```
### Objects (Instances) {#objects-(instances)}
An object is a specific instance of a class. You create objects using the `new` keyword.
```java
Dog myDog = new Dog(); // Create a Dog object
myDog.breed = "Golden Retriever";
myDog.age = 3;
myDog.bark(); // Call the bark() method
```
### Constructors {#constructors}
Constructors are special methods that are called when an object is created. They are used to initialize the object's attributes. If you don't define a constructor, Java provides a default no-argument constructor.
```java
public class Dog {
String breed;
int age;
// Constructor
public Dog(String breed, int age) {
this.breed = breed;
this.age = age;
}
public void bark() {
System.out.println("Woof!");
}
}
// Creating an object using the constructor:
Dog myDog = new Dog("Golden Retriever", 3);
```
### Access Modifiers {#access-modifiers}
Control the visibility of class members (attributes and methods).
- **public**: Accessible from anywhere.
- **private**: Accessible only within the class.
- **protected**: Accessible within the class, subclasses, and other classes in the same package.
- **(Default - package-private)**: Accessible within the same package.
## Methods {#methods}
Methods are blocks of code that perform specific tasks. They are also known as functions in other programming languages.
### Method Definition {#method-definition}
Methods have a name, a return type, and a list of parameters (optional).
```java
public int add(int a, int b) {
int sum = a + b;
return sum;
}
```
- **public**: Access modifier.
- **int**: Return type (the type of data the method returns). If a method doesn't return a value, use `void`.
- **add**: Method name.
- **(int a, int b)**: Parameter list (input values).
- **return sum;**: Returns the calculated sum.
### Method Calling {#method-calling}
To execute a method, you need to call it by its name, providing the necessary arguments (values for the parameters).
```java
int result = add(5, 3); // Calling the add() method
System.out.println(result); // Output: 8
```
### Method Overloading {#method-overloading}
Defining multiple methods with the same name but different parameter lists within the same class. The compiler determines which method to call based on the arguments passed.
```java
public int add(int a, int b) {
return a + b;
}
public double add(double a, double b) {
return a + b;
}
// Calling the overloaded methods:
int sumInt = add(5, 3);
double sumDouble = add(5.5, 3.2);
```
### static Methods {#static-methods}
Belong to the class itself rather than to any specific object. They can be called directly using the class name.
```java
public class MathUtils {
public static int square(int num) {
return num * num;
}
}
// Calling the static method:
int squaredValue = MathUtils.square(5); // No object needed
```
## Loops {#loops}
Loops are used to execute a block of code repeatedly. Java provides several types of loops.
### for Loop {#for-loop}
Used when you know how many times you want to execute the loop.
```java
for (int i = 0; i < 5; i++) {
System.out.println("Iteration: " + i);
}
```
- **int i = 0**: Initialization (executed once at the beginning).
- **i < 5**: Condition (checked before each iteration).
- **i++**: Increment (executed after each iteration).
### while Loop {#while-loop}
Used when you want to execute a loop as long as a certain condition is true.
```java
int count = 0;
while (count < 5) {
System.out.println("Count: " + count);
count++;
}
```
### do-while Loop {#do-while-loop}
Similar to while loop, but the code block is executed at least once, even if the condition is initially false.
```java
int num = 0;
do {
System.out.println("Number: " + num);
num++;
} while (num < 5);
```
### for-each Loop (Enhanced for Loop) {#for-each-loop-(enhanced-for-loop)}
Used to iterate over elements in an array or collection.
```java
int[] numbers = {1, 2, 3, 4, 5};
for (int number: numbers) {
System.out.println(number);
}
```
### break and continue Statements {#break-and-continue-statements}
- **break**: Exits the loop immediately.
- **continue**: Skips the current iteration and proceeds to the next one.
## Arrays {#arrays}
Arrays are data structures that store a fixed-size sequence of elements of the same data type.
### Array Declaration and Initialization {#array-declaration-and-initialization}
You must declare the data type of the elements the array will hold.
```java
int[] numbers = new int[5]; // Declaration and initialization (size 5)
numbers[0] = 10; // Assigning values to elements
numbers[1] = 20;
numbers[2] = 30;
numbers[3] = 40;
numbers[4] = 50;
// Or, you can initialize an array with values directly:
int[] numbers2 = {10, 20, 30, 40, 50};
```
### Accessing Array Elements {#accessing-array-elements}
Use the index (starting from 0) to access elements.
```java
int firstElement = numbers[0]; // Accessing the first element (value: 10)
System.out.println(firstElement);
```
### Array Length {#array-length}
Use the `length` property to get the number of elements in the array.
```java
int arrayLength = numbers.length; // Getting the array length (value: 5)
System.out.println(arrayLength);
```
### Multidimensional Arrays {#multidimensional-arrays}
Arrays can have multiple dimensions (e.g., 2D arrays for representing matrices).
```java
int[][] matrix = {
{1, 2, 3},
{4, 5, 6},
{7, 8, 9}
};
int element = matrix[1][2]; // Accessing element at row 1, column 2 (value: 6)
```
## Strings {#strings}
Strings represent sequences of characters. In Java, `String` is a class (not a primitive type), and strings are immutable (their values cannot be changed after creation).
### String Creation {#string-creation}
You can create strings using string literals or the `new` keyword.
```java
String message = "Hello, world!"; // String literal
String anotherMessage = new String("Hello, world!"); // Using the new keyword
```
### String Methods {#string-methods}
The `String` class provides many useful methods for manipulating strings.
- **length()**: Returns the length of the string.
- **charAt(int index)**: Returns the character at the specified index.
- **substring(int beginIndex, int endIndex)**: Returns a substring.
- **equals(String anotherString)**: Checks if two strings are equal (case-sensitive).
- **equalsIgnoreCase(String anotherString)**: Checks if two strings are equal (case-insensitive).
- **toUpperCase()**: Converts the string to uppercase.
- **toLowerCase()**: Converts the string to lowercase.
- **trim()**: Removes leading and trailing whitespace.
- **indexOf(String str)**: Returns the index of the first occurrence of the specified substring.
- **replace(String oldStr, String newStr)**: Replaces occurrences of a substring with another.
```java
String text = " Java Programming ";
System.out.println(text.length()); // Output: 23
System.out.println(text.trim().length()); // Output: 17
System.out.println(text.charAt(4)); // Output: a
System.out.println(text.substring(3, 7)); // Output: a Pr
System.out.println(text.toUpperCase()); // Output: JAVA PROGRAMMING
```
### String Concatenation {#string-concatenation}
You can combine strings using the `+` operator or the `concat()` method.
```java
String firstName = "John";
String lastName = "Doe";
String fullName = firstName + " " + lastName; // Using the + operator
String fullName2 = firstName.concat(" ").concat(lastName); // Using the concat() method
System.out.println(fullName); // Output: John Doe
System.out.println(fullName2); // Output: John Doe
```
### Immutability {#immutability}
Strings are immutable, meaning that once a string object is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new string object.
```java
String message = "Hello";
message = message + ", world!"; // A new string object is created
System.out.println(message); // Output: Hello, world!
```
## Getters and Setters {#getters-and-setters}
Getters and setters are methods used to access and modify the private attributes of a class. They are part of the concept of encapsulation.
**Encapsulation**: Bundling the data (attributes) and methods that operate on that data within a class, and hiding the internal implementation details from the outside world.
- **Getter Methods**: Used to retrieve the value of a private attribute. They are typically named `getVariableName()`.
- **Setter Methods**: Used to modify the value of a private attribute. They are typically named `setVariableName(newValue)`.
```java
public class Person {
private String name;
private int age;
// Getter for name
public String getName() {
return name;
}
// Setter for name
public void setName(String name) {
this.name = name;
}
// Getter for age
public int getAge() {
return age;
}
// Setter for age
public void setAge(int age) {
if (age >= 0) { // Add validation if needed
this.age = age;
}
}
}
```
### Usage Example {#usage-example}
```java
// Using getters and setters:
Person person = new Person();
person.setName("Alice");
person.setAge(30);
System.out.println("Name: " + person.getName()); // Output: Name: Alice
System.out.println("Age: " + person.getAge()); // Output: Age: 30
```
### Benefits of Getters and Setters {#benefits-of-getters-and-setters}
- **Encapsulation**: Protects the internal state of the object.
- **Data Validation**: Allows you to add validation logic to the setter methods to ensure data integrity.
- **Flexibility**: Provides a controlled way to access and modify attributes, allowing you to change the internal implementation without affecting the external code that uses the class.
## Inheritance {#inheritance}
Inheritance is a mechanism that allows a class (subclass or derived class) to inherit attributes and methods from another class (superclass or base class). It promotes code reuse and establishes an "is-a" relationship between classes.
### extends Keyword {#extends-keyword}
Use the `extends` keyword to indicate that a class inherits from another class.
```java
class Animal {
String name;
void eat() {
System.out.println("Animal is eating");
}
}
class Dog extends Animal { // Dog inherits from Animal
void bark() {
System.out.println("Dog is barking");
}
}
// Using inheritance:
Dog myDog = new Dog();
myDog.name = "Buddy"; // Inherited from Animal
myDog.eat(); // Inherited from Animal
myDog.bark(); // Defined in Dog
```
### super Keyword {#super-keyword}
Used to call the constructor or methods of the superclass from within the subclass.
```java
class Animal {
String name;
Animal(String name) {
this.name = name;
}
void eat() {
System.out.println("Animal is eating");
}
}
class Dog extends Animal {
String breed;
Dog(String name, String breed) {
super(name); // Call the Animal constructor
this.breed = breed;
}
void bark() {
System.out.println("Dog is barking");
}
}
```
### Method Overriding {#method-overriding}
A subclass can provide a specific implementation for a method that is already defined in its superclass. The method signature (name and parameters) must be the same.
```java
class Animal {
void makeSound() {
System.out.println("Generic animal sound");
}
}
class Dog extends Animal {
@Override // Good practice to use the @Override annotation
void makeSound() {
System.out.println("Woof!"); // Override the makeSound() method
}
}
// Using method overriding:
Animal animal = new Animal();
animal.makeSound(); // Output: Generic animal sound
Dog dog = new Dog();
dog.makeSound(); // Output: Woof!
```
### Single Inheritance {#single-inheritance}
Java only supports single inheritance, meaning a class can inherit from only one direct superclass. However, a class can implement multiple interfaces.
## Encapsulation {#encapsulation}
Encapsulation is one of the four fundamental principles of object-oriented programming (OOP). It describes the idea of bundling data (attributes) and methods that operate on that data within one unit (a class), and restricting direct access to some of the object's components.
- **Data Hiding**: Restricting direct access to the internal data (attributes) of a class by declaring them as `private`.
- **Access Modifiers**: `private`, `protected`, and `public` are used to control the visibility of class members. `private` is the most restrictive, providing the highest level of encapsulation.
- **Getters and Setters (Accessor and Mutator Methods)**: Provide controlled access to the private attributes of a class.
### Benefits of Encapsulation {#benefits-of-encapsulation}
- **Data Protection**: Prevents unauthorized access and modification of data.
- **Code Maintainability**: Makes it easier to modify the internal implementation of a class without affecting the external code that uses it.
- **Flexibility**: Allows you to change the internal representation of data without breaking the code that uses the class.
- **Modularity**: Promotes modularity by creating self-contained units (classes) that are responsible for their own data and behavior.
## Polymorphism {#polymorphism}
Polymorphism (meaning "many forms") is the ability of an object to take on many forms. In Java, it is typically achieved through inheritance and interfaces.
### Two Types of Polymorphism {#two-types-of-polymorphism}
- **Compile-time Polymorphism (Static Polymorphism or Method Overloading)**: Achieved through method overloading, where multiple methods with the same name but different parameter lists exist in a class. The compiler determines which method to call based on the arguments passed.
- **Runtime Polymorphism (Dynamic Polymorphism or Method Overriding)**: Achieved through method overriding, where a subclass provides a specific implementation for a method that is already defined in its superclass. The method to be called is determined at runtime based on the actual object type.
### Method Overriding (Runtime Polymorphism) {#method-overriding-(runtime-polymorphism)}
```java
class Animal {
void makeSound() {
System.out.println("Generic animal sound");
}
}
class Dog extends Animal {
@Override
void makeSound() {
System.out.println("Woof!");
}
}
class Cat extends Animal {
@Override
void makeSound() {
System.out.println("Meow!");
}
}
// Polymorphic behavior:
Animal animal1 = new Animal();
Animal animal2 = new Dog(); // Animal reference to a Dog object
Animal animal3 = new Cat(); // Animal reference to a Cat object
animal1.makeSound(); // Output: Generic animal sound
animal2.makeSound(); // Output: Woof! (Dog's makeSound is called)
animal3.makeSound(); // Output: Meow! (Cat's makeSound is called)
```
### Interfaces and Polymorphism {#interfaces-and-polymorphism}
Interfaces define a contract that classes can implement. A class can implement multiple interfaces. This allows objects of different classes to be treated as objects of the same interface type, enabling polymorphic behavior.
```java
interface Shape {
double getArea();
}
class Circle implements Shape {
double radius;
Circle(double radius) {
this.radius = radius;
}
@Override
public double getArea() {
return Math.PI * radius * radius;
}
}
class Rectangle implements Shape {
double width;
double height;
Rectangle(double width, double height) {
this.width = width;
this.height = height;
}
@Override
public double getArea() {
return width * height;
}
}
// Polymorphic behavior:
Shape shape1 = new Circle(5);
Shape shape2 = new Rectangle(4, 6);
System.out.println("Circle area: " + shape1.getArea()); // Output: Circle area: 78.53981633974483
System.out.println("Rectangle area: " + shape2.getArea()); // Output: Rectangle area: 24.0
```
### Benefits of Polymorphism {#benefits-of-polymorphism}
- **Flexibility**: Allows you to write code that can work with objects of different types in a uniform way.
- **Extensibility**: Makes it easier to add new classes and functionality to a program without modifying existing code.
- **Code Reusability**: Promotes code reuse by allowing you to write generic code that can work with a variety of objects.
- **Maintainability**: Improves code maintainability by making it easier to understand and modify.
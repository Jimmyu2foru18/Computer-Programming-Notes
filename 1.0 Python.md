# Python Programming: Complete Learning Guide

## Table of Contents
1. [Packages and Modules](#packages-and-modules)
2. [Variables](#variables)
3. [Classes and Methods](#Classes-and-Methods)
4. [Loops](#Loops)
5. [Arrays (Lists)](#Arrays-Lists)
6. [Strings](#Strings)
7. [Getters and Setters](#Getters-and-Setters)
8. [Inheritance](#Inheritance)
9. [Encapsulation](#Encapsulation)
10. [Polymorphism](#Polymorphism)

---
## Packages and Modules

### Introduction
- Python's strength lies in its extensive collection of packages and modules. 
- These are essentially reusable code libraries that provide pre-built functionalities, allowing you to avoid reinventing the wheel.

### Modules
- A module is a single file containing Python code. 
- You can import modules using the import statement. 
- For example:
```python
import math
print(math.sqrt(16)) # Output: 4.0
```

### Packages
- A package is a collection of modules organized into a directory hierarchy. 
- A package must contain a file named __init__.py, which can be empty or can contain initialization code for the package. 
- Packages help organize large projects into manageable units.

### Example
- For example, if you have a directory structure like this:
```javascript
my_package/
__init__.py
module1.py
module2.py
```

You can import modules from the package like this:
```python
import my_package.module1
my_package.module1.some_function()
```
Or:

```python
from my_package import module1
module1.some_function()
```

### Installing Packages
- Python packages are typically installed using pip, the Python package installer.
- You can install packages using the following command:
```bash
pip install requests
```
This will install the requests package, which is commonly used for making HTTP requests. After installation, you can import and use it in your code.

### Using the Package
- After installation, you can import and use the package in your Python code.
- For example:
```python
import requests
response = requests.get("https://www.example.com")
print(response.status_code)
```
## Variables
- Variables are used to store data in Python.
- Unlike some languages, Python is dynamically typed, meaning you don't need to explicitly declare the type of a variable.
- The type is inferred at runtime.

### Assignment
You assign a value to a variable using the `=` operator.
```python
x = 10
name = "Alice"
is_valid = True
```
### Data Types
Common data types include:
- **int**: Integers (10, -5, 0)
- **float**: Floating-point numbers (3.14, -2.5)
- **str**: Strings ("Hello", "Python")
- **bool**: Boolean values (True, False)
- **list**: Ordered, mutable collections of items ([1, 2, 3], ["a", "b", "c"])
- **tuple**: Ordered, immutable collections of items ((1, 2, 3), ("a", "b", "c"))
- **dict**: Key-value pairs ({"name": "Alice", "age": 30})
- **set**: Unordered collections of unique items ({1, 2, 3}, {"a", "b", "c"})
- **None**: Represents the absence of a value or a null value.

### Variable Naming
- Variable names must start with a letter or underscore.
- They can contain letters, numbers, and underscores.
- They are case-sensitive (`myVar` and `myvar` are different variables).
- It's recommended to use descriptive names and follow the `snake_case` convention (`user_name`, `total_count`).

## Classes and Methods:
- Classes are blueprints for creating objects. They define the attributes (data) and methods (behavior) that objects of that class will have.
- Defining a Class:
```python
class Dog:
def __init__(self, name, breed):
self.name = name
self.breed = breed
def bark(self):
print("Woof!")
```

**class Dog**: Defines a class named Dog.
**def __init__(self, name, breed)**: This is the constructor (or initializer) method. 
- It's called when you create a new object of the class. 
- self refers to the instance of the class. 
- name and breed are parameters that are passed when you create a Dog object.
**self.name = name**: Assigns the value of the name parameter to the name attribute of the object.
**self.breed = breed**: Assigns the value of the breed parameter to the breed attribute of the object.

**def bark(self)**: This is a method of the Dog class. 
- It takes self as a parameter (to access the object's attributes) and prints "Woof!".

### Creating an Object (Instance):
```python
my_dog = Dog("Buddy", "Golden Retriever")
print(my_dog.name) # Output: Buddy
my_dog.bark() # Output: Woof!
```
**my_dog = Dog("Buddy", "Golden Retriever")**: Creates a new Dog object named my_dog. 
- The arguments "Buddy" and "Golden Retriever" are passed to the __init__ method.
- The __init__ method initializes the object's attributes (name and breed) with the provided values.
**print(my_dog.name)**: Accesses the name attribute of the my_dog object.
**my_dog.bark()**: Calls the bark method of the my_dog object.
- The bark method prints "Woof!".

## Methods:
- Methods are functions defined within a class. They operate on the object's data.
```python
class Rectangle:
def __init__(self, width, height):
self.width = width
self.height = height
def area(self):
return self.width * self.height
def perimeter(self):
return 2 * (self.width + self.height)
rect = Rectangle(5, 10)
print(rect.area()) # Output: 50
print(rect.perimeter()) # Output: 30
```

## Loops:
- Loops are used to repeatedly execute a block of code. Python has two main types of loops: for and while.
for Loop: Iterates over a sequence (a list, tuple, string, or range).
```python
# Iterating over a list {#iterating-over-a-list}
fruits = ["apple", "banana", "cherry"]
for fruit in fruits:
print(fruit)
```
```python
# Iterating over a range of numbers {#iterating-over-a-range-of-numbers}
for i in range(5): # range(5) generates numbers from 0 to 4
print(i)
```

```python
# Iterating over a string {#iterating-over-a-string}
for char in "Python":
print(char)
```

### while Loop
Executes a block of code as long as a condition is true.
```python
count = 0
while count < 5:
print(count)
count += 1 # Increment count
```

### break and continue
- **break**: Exits the loop prematurely.
- **continue**: Skips the current iteration and proceeds to the next.
```python
for i in range(10):
if i == 3:
break # Exit the loop when i is 3
if i == 1:
continue # Skip the rest of the loop body if i is 1
print(i)
```

## Arrays (Lists)
Arrays, implemented as lists in Python, are ordered collections of items. They are mutable, meaning you can change their contents after creation.

### Creating a List
```python
my_list = [1, 2, 3, "apple", "banana"]
```

### Accessing Elements
You can access elements using their index (starting from 0).
```python
print(my_list[0]) # Output: 1
print(my_list[3]) # Output: apple
```

### Slicing
You can extract a portion of a list using slicing.
```python
print(my_list[1:4]) # Output: [2, 3, 'apple'] (elements from index 1 up to, but not including, index 4)
print(my_list[:3]) # Output: [1, 2, 3] (elements from the beginning up to index 3)
print(my_list[2:]) # Output: [3, 'apple', 'banana'] (elements from index 2 to the end)
```

### List Methods
Python provides various methods for manipulating lists.
- **append(item)**: Adds an item to the end of the list.
- **insert(index, item)**: Inserts an item at a specific index.
- **remove(item)**: Removes the first occurrence of an item.
- **pop(index)**: Removes and returns the item at a specific index (defaults to the last item if no index is provided).
- **len(list)**: Returns the number of elements in the list.
  
```python
numbers = [1, 2, 3]
numbers.append(4) # numbers is now [1, 2, 3, 4]
numbers.insert(1, 5) # numbers is now [1, 5, 2, 3, 4]
numbers.remove(2) # numbers is now [1, 5, 3, 4]
popped_item = numbers.pop(1) #numbers is now [1, 3, 4], popped_item is 5
print(numbers)
print(len(numbers)) #prints 3
```

## Strings
Strings are sequences of characters. They are immutable, meaning you cannot change them directly after creation.

### Creating Strings
```python
my_string = "Hello, Python!"
```

### String Methods
Python provides many methods for string manipulation.
- **len(string)**: Returns the length of the string.
- **string.lower()**: Converts the string to lowercase.
- **string.upper()**: Converts the string to uppercase.
- **string.strip()**: Removes leading and trailing whitespace.
- **string.split(delimiter)**: Splits the string into a list of substrings based on the delimiter.
- **string.replace(old, new)**: Replaces all occurrences of old with new.
- **string.find(substring)**: Returns the index of the first occurrence of substring (or -1 if not found).

```python
text = " Python is fun! "
print(len(text)) #prints 18
print(text.lower()) # Output: " python is fun! "
print(text.upper()) # Output: " PYTHON IS FUN! "
print(text.strip()) # Output: "Python is fun!"
print(text.split(" ")) # Output: ['', '', 'Python', 'is', 'fun!', '', '']
print(text.replace("fun", "awesome")) # Output: " Python is awesome! "
print(text.find("is")) # Output: 9
```

### String Formatting
You can use f-strings (formatted string literals) for easy string formatting.
```python
name = "Bob"
age = 25
message = f"My name is {name} and I am {age} years old."
print(message) # Output: My name is Bob and I am 25 years old.
```

## Getters and Setters
Getters and setters are methods used to access and modify the attributes of an object. 
They provide a way to encapsulate the internal state of an object and control how its attributes are accessed and modified. 
Although not strictly required in Python due to its dynamic nature, they are useful for validation and control.

### Basic Getters and Setters
```python
class Person:
def __init__(self, name, age):
self._name = name # Use a single underscore to indicate it is 'protected'
self._age = age
def get_name(self):
return self._name
def set_name(self, name):
if not isinstance(name, str):
raise ValueError("Name must be a string")
self._name = name
def get_age(self):
return self._age
def set_age(self, age):
if not isinstance(age, int):
raise ValueError("Age must be an integer")
if age < 0:
raise ValueError("Age cannot be negative")
self._age = age
```

**Explanation:**
- **_name and _age**: We use a single underscore prefix to indicate that these attributes are intended for internal use (protected).
- Python doesn't enforce true private attributes like some other languages, but this is a widely followed convention.

- **get_name(self) and get_age(self)**: These are the getter methods. They simply return the value of the corresponding attribute.
- **set_name(self, name) and set_age(self, age)**: These are the setter methods. They take a new value as input, perform validation, and then update the attribute.

### Using Getters and Setters
```python
person = Person("Alice", 30)
print(person.get_name()) # Output: Alice
person.set_age(31)
print(person.get_age()) # Output: 31
try:
person.set_age(-5)
except ValueError as e:
print(e) #prints "Age cannot be negative"
```

### Property Decorators (Advanced)
Python provides a more elegant way to define getters and setters using property decorators.
```python
class Circle:
def __init__(self, radius):
self._radius = radius
@property
def radius(self):
return self._radius
@radius.setter
def radius(self, radius):
if radius <= 0:
raise ValueError("Radius must be positive")
self._radius = radius
@property
def area(self):
return 3.14159 * self._radius * self._radius
```

**Explanation:**
- **@property**: This decorator turns the radius method into a property, allowing you to access it like an attribute (`circle.radius`) instead of a method (`circle.radius()`).
- **@radius.setter**: This decorator defines the setter method for the radius property. It's called when you assign a value to `circle.radius`.
- **@property area**: defines a read-only property. You can access `circle.area` but not set its value directly.
```python
circle = Circle(5)
print(circle.radius) # Output: 5
circle.radius = 7
print(circle.area) # Output: 153.93791
```

## Inheritance
Inheritance allows you to create new classes (child classes or subclasses) that inherit attributes and methods from existing classes (parent classes or superclasses). 
This promotes code reuse and establishes relationships between classes.

### Basic Inheritance
```python
class Animal:
def __init__(self, name):
self.name = name
def speak(self):
print("Generic animal sound")
class Dog(Animal): # Dog inherits from Animal
def __init__(self, name, breed):
super().__init__(name) # Call the parent class's constructor
self.breed = breed
def speak(self): # Override the speak method
print("Woof!")
```
**Explanation:**
- **class Dog(Animal)**: This indicates that the Dog class inherits from the Animal class.
- **super().__init__(name)**: This calls the constructor of the parent class (Animal) to initialize the name attribute.
- It's important to call the parent's constructor to ensure proper initialization.
- **speak(self)**: This method overrides the speak method in the Animal class.
- When you call speak() on a Dog object, this overridden method will be executed.
  
### Using Inheritance
```python
animal = Animal("Generic Animal")
animal.speak() #prints "Generic animal sound"
dog = Dog("Buddy", "Golden Retriever")
print(dog.name) # Output: Buddy (inherited from Animal)
print(dog.breed) # Output: Golden Retriever
dog.speak() # Output: Woof! (overridden method)
```

### Multiple Inheritance
Python supports multiple inheritance, where a class can inherit from multiple parent classes.
```python
class Swimmer:
def swim(self):
print("Swimming")
class Walker:
def walk(self):
print("Walking")
class Duck(Swimmer, Walker): # Duck inherits from both Swimmer and Walker
pass
duck = Duck()
duck.swim() # Output: Swimming
duck.walk() # Output: Walking
```

## Encapsulation 
Encapsulation is the bundling of data (attributes) and methods that operate on that data within a class. 
It helps protect the internal state of an object and prevent direct access from outside the class.

### Access Modifiers (Convention)
Python doesn't have strict access modifiers like private or protected found in other languages. 
Instead, it relies on naming conventions.

- **public**: Attributes and methods without any prefix are considered public and can be accessed from anywhere.
- **__private**: Attributes and methods with a double underscore prefix are name-mangled.
- This makes them harder to access directly from outside the class. However, they are not truly private.
- **_protected**: Attributes and methods with a single underscore prefix are considered protected.
- They are intended for internal use within the class and its subclasses.
- While you can still access them from outside, it's a signal that you shouldn't.

### Example
```python
class BankAccount:
def __init__(self, account_number, balance):
self.account_number = account_number # public
self._balance = balance # protected. Can be accessed but should not be.
self.__transaction_history = [] #name mangled. Accessible, but harder to access
def deposit(self, amount):
if amount > 0:
self._balance += amount
self.__transaction_history.append(f"Deposit: {amount}")
else:
print("Invalid deposit amount")
def withdraw(self, amount):
if 0 < amount <= self._balance:
self._balance -= amount
self.__transaction_history.append(f"Withdrawal: {amount}")
else:
print("Insufficient funds or invalid amount")
def get_balance(self):
return self._balance
def get_transaction_history(self):
return self.__transaction_history # Direct access to 'private' attribute is allowed.
account = BankAccount("12345", 1000)
account.deposit(500)
account.withdraw(200)
print(account.get_balance()) # Output 1300
print(account.account_number) # Output 12345
print(account.get_transaction_history())
# Accessing "private" attribute (discouraged but possible) {#accessing-private-attribute-discouraged-but-possible}
print(account._BankAccount__transaction_history)
```

## Polymorphism
Polymorphism means "many forms." In object-oriented programming, it refers to the ability of objects of different classes to respond to the same method call in their own specific ways.

### Duck Typing
Python uses a concept called "duck typing." If it walks like a duck and quacks like a duck, then it is a duck. 
In other words, the type of an object is less important than whether it has the methods and attributes you need.

### Method Overriding (Inheritance)
As shown in the Inheritance section, subclasses can override methods of their parent classes to provide specialized behavior. 
This is a form of polymorphism.

### Example
```python
class Animal:
def speak(self):
print("Generic animal sound")
class Dog(Animal):
def speak(self):
print("Woof!")
class Cat(Animal):
def speak(self):
print("Meow!")
def animal_sound(animal):
animal.speak() # Polymorphic call: the correct speak() method is called based on the object's type
animal = Animal()
dog = Dog()
cat = Cat()
animal_sound(animal) # Output: Generic animal sound
animal_sound(dog) # Output: Woof!
animal_sound(cat) # Output: Meow!
```

**Explanation:**
- **class Dog(Animal)**: This indicates that the Dog class inherits from the Animal class.
- **super().__init__(name)**: This calls the constructor of the parent class (Animal) to initialize the name attribute.
- It's important to call the parent's constructor to ensure proper initialization.
  
- **speak(self)**: This method overrides the speak method in the Animal class.
- When you call speak() on a Dog object, this overridden method will be executed.

### Operator Overloading
Python allows you to redefine the behavior of operators (e.g., +, -, *, /) for your own classes. 
This is another form of polymorphism.
```python
class Point:
def __init__(self, x, y):
self.x = x
self.y = y
def __add__(self, other):
return Point(self.x + other.x, self.y + other.y)
def __str__(self):
return f"({self.x}, {self.y})"
p1 = Point(1, 2)
p2 = Point(3, 4)
p3 = p1 + p2 # Uses the overloaded __add__ operator
print(p3) # Output: (4, 6) (uses the overloaded __str__ operator)
```
---

# C# Guide: From Beginner to Advanced {#c-guide-from-beginner-to-advanced}
## Table of Contents {#table-of-contents}
1. [Introduction to C# and.NET](#introduction-to-c-andnet)
2. [Setting Up Your Development Environment](#setting-up-your-development-environment)
3. [Your First C# Program](#your-first-c-program)
4. [C# Fundamentals](#c-fundamentals)
5. [Object-Oriented Programming](#object-oriented-programming)
6. [Collections and Data Structures](#collections-and-data-structures)
7. [Exception Handling](#exception-handling)
8. [File I/O Operations](#file-io-operations)
9. [LINQ](#linq)
10. [Asynchronous Programming](#asynchronous-programming)
11. [Advanced Topics](#advanced-topics)
---
## Introduction to C# and.NET {#introduction-to-c#-and.net}
C# (pronounced "See Sharp") is a modern, object-oriented, and type-safe programming language. It's part of the.NET ecosystem, a comprehensive framework developed by Microsoft. This guide covers C# from the absolute basics to advanced concepts.
### What is.NET? {#what-is.net?}
.NET is a free, cross-platform, open-source developer platform for building many different types of applications. With.NET, you can use multiple languages, editors, and libraries to build for web, mobile, desktop, games, and IoT..NET consists of: 
- **Runtime**: The Common Language Runtime (CLR) manages the execution of.NET programs. It provides services like memory management (garbage collection), exception handling, and thread management.
- **Framework**: A vast set of pre-built classes, interfaces, and value types (collectively known as the Base Class Library or BCL) that provide functionality for common programming tasks such as file I/O, networking, data access, and UI development.
- **Languages**: C# is the primary language for.NET development, but you can also use other languages like F# and Visual Basic.
## Setting Up Your Development Environment {#setting-up-your-development-environment}
To start developing with C#, you'll need the.NET SDK (Software Development Kit) and an IDE (Integrated Development Environment).
### Install the.NET SDK {#install-the.net-sdk}
- Download the latest version of the.NET SDK from the official Microsoft website. Make sure to choose the SDK and not just the Runtime.
- Follow the installation instructions for your operating system (Windows, macOS, Linux).
### Choose an IDE {#choose-an-ide}
- **Visual Studio (Recommended)**: A powerful and feature-rich IDE specifically designed for.NET development. It provides excellent support for C#, including IntelliSense (code completion), debugging tools, and project management features.
- **Visual Studio Code**: A lightweight and cross-platform code editor with excellent C# support through the C# extension. Great for smaller projects or if you prefer a more streamlined environment.
- **JetBrains Rider**: A cross-platform.NET IDE known for its intelligent code analysis and refactoring features. A good option if you're already familiar with JetBrains IDEs.
## Your First C# Program {#your-first-c#-program}
Let's create a simple "Hello, World!" program to get started.
### Steps {#steps}
1. Open Visual Studio (or your chosen IDE).
2. Create a new project:
- Choose a console application template (e.g., "Console App" in Visual Studio).
- Give your project a name (e.g., "HelloWorld").
3. Replace the code in Program.cs with the following:
```csharp
using System;
namespace HelloWorld
{
class Program
{
static void Main(string[] args)
{
Console.WriteLine("Hello, World!");
Console.ReadKey(); // Keeps the console window open until a key is pressed
}
}
}
```
4. Run the program:
- In Visual Studio, press Ctrl+F5 (or click "Debug" -> "Start Without Debugging").
- You should see "Hello, World!" printed in the console window.
### Understanding the Code {#understanding-the-code}
- `using System;`: This line imports the System namespace, which contains commonly used classes like Console.
- `namespace HelloWorld`: A namespace is a container that organizes code and helps prevent naming conflicts.
- `class Program`: A class is a blueprint for creating objects. In this case, Program is the class that contains the main entry point of the application.
- `static void Main(string[] args)`: The Main method is the entry point of the application. It's where the program starts executing.
- `static`: Means the method belongs to the class itself, not to an instance of the class.
- `void`: Indicates that the method doesn't return any value.
- `string[] args`: An array of strings that can be used to pass command-line arguments to the program.
- `Console.WriteLine("Hello, World!");`: This line uses the WriteLine method of the Console class to print the text "Hello, World!" to the console.
- `Console.ReadKey();`: This line waits for the user to press a key before closing the console window.
## C# Fundamentals {#c#-fundamentals}
### Variables and Data Types {#variables-and-data-types}
Variables are used to store data in a program. Each variable has a data type that specifies the kind of data it can hold.
#### Common Data Types {#common-data-types}
- `int`: Represents integers (whole numbers) e.g., 10, -5, 0.
- `double`: Represents double-precision floating-point numbers (numbers with decimal points) e.g., 3.14, -2.5, 0.0.
- `float`: Represents single-precision floating-point numbers. Use 'f' suffix to indicate a float literal. e.g., 3.14f. Generally, double is preferred for better precision.
- `decimal`: Represents a decimal number, designed for financial calculations. Use 'm' suffix to indicate a decimal literal. e.g., 19.99m. Offers higher precision than double for decimal values.
- `string`: Represents a sequence of characters (text) e.g., "Hello", "World".
- `bool`: Represents a boolean value (either true or false).
- `char`: Represents a single character e.g., 'A', '7', '$'.
#### Declaration and Initialization {#declaration-and-initialization}
```csharp
int age = 30; // Declare an integer variable named 'age' and initialize it to 30
double price = 19.99; // Declare a double variable named 'price' and initialize it to 19.99
string name = "John Doe"; // Declare a string variable named 'name' and initialize it to "John Doe"
bool isAdult = true; // Declare a boolean variable named 'isAdult' and initialize it to true
```
#### Type Inference (var keyword) {#type-inference-(var-keyword)}
C# can infer the type of a variable based on the value assigned to it.
```csharp
var quantity = 10; // 'quantity' will be inferred as an int
var message = "Hello"; // 'message' will be inferred as a string
```
#### Constants {#constants}
Use the `const` keyword to declare a constant variable, whose value cannot be changed after initialization.
```csharp
const double PI = 3.14159;
```
### Operators {#operators}
Operators are symbols that perform operations on variables and values.
#### Arithmetic Operators {#arithmetic-operators}
- `+` (Addition)
- `-` (Subtraction)
- `*` (Multiplication)
- `/` (Division)
- `%` (Modulo - returns the remainder of a division)
#### Assignment Operators {#assignment-operators}
- `=` (Assignment)
- `+=` (Add and assign)
- `-=` (Subtract and assign)
- `*=` (Multiply and assign)
- `/=` (Divide and assign)
- `%=` (Modulo and assign)
#### Comparison Operators {#comparison-operators}
- `==` (Equal to)
- `!=` (Not equal to)
- `>` (Greater than)
- `<` (Less than)
- `>=` (Greater than or equal to)
- `<=` (Less than or equal to)
#### Logical Operators {#logical-operators}
- `&&` (Logical AND)
- `||` (Logical OR)
- `!` (Logical NOT)
#### Increment and Decrement Operators {#increment-and-decrement-operators}
- `++` (Increment)
- `--` (Decrement)
#### Example {#example}
```csharp
int x = 10;
int y = 5;
int sum = x + y; // sum is 15
int difference = x - y; // difference is 5
int product = x * y; // product is 50
int quotient = x / y; // quotient is 2
int remainder = x % y; // remainder is 0
x++; // x is now 11
y--; // y is now 4
bool isEqual = (x == y); // isEqual is false
bool isGreaterThan = (x > y); // isGreaterThan is true
bool result = (isGreaterThan &&!isEqual); // result is true
```
### Control Flow Statements {#control-flow-statements}
Control flow statements allow you to control the order in which code is executed.
#### if statement {#if-statement}
Executes a block of code if a condition is true.
```csharp
int age = 20;
if (age >= 18)
{
Console.WriteLine("You are an adult.");
}
```
#### if-else statement {#if-else-statement}
```csharp
int age = 20;
if (age >= 18)
{
Console.WriteLine("You are an adult.");
}
else
{
Console.WriteLine("You are a minor.");
}
```
#### switch statement {#switch-statement}
Executes one of several blocks of code based on the value of an expression.
```csharp
int day = 3;
switch (day)
{
case 1:
Console.WriteLine("Monday");
break;
case 2:
Console.WriteLine("Tuesday");
break;
case 3:
Console.WriteLine("Wednesday");
break;
default:
Console.WriteLine("Invalid day");
break;
}
```
#### for loop {#for-loop}
Executes a block of code repeatedly for a specified number of times.
```csharp
for (int i = 0; i < 10; i++)
{
Console.WriteLine("Iteration: " + i);
}
```
#### while loop {#while-loop}
Executes a block of code repeatedly as long as a condition is true.
```csharp
int count = 0;
while (count < 5)
{
Console.WriteLine("Count: " + count);
count++;
}
```
#### do-while loop {#do-while-loop}
Executes a block of code repeatedly as long as a condition is true, but it executes the block at least once.
```csharp
int number = 0;
do
{
Console.WriteLine("Number: " + number);
number++;
} while (number < 3);
```
#### foreach loop {#foreach-loop}
Iterates over the elements of a collection (e.g., an array or a list).
```csharp
string[] names = { "Alice", "Bob", "Charlie" };
foreach (string name in names)
{
Console.WriteLine("Name: " + name);
}
```
### Arrays {#arrays}
Arrays are used to store a fixed-size sequence of elements of the same type.
#### Declaration and Initialization {#declaration-and-initialization}
```csharp
int[] numbers = new int[5]; // Creates an array of 5 integers
numbers[0] = 10;
numbers[1] = 20;
numbers[2] = 30;
numbers[3] = 40;
numbers[4] = 50;
int[] moreNumbers = { 1, 2, 3, 4, 5 }; // Creates and initializes an array
```
#### Accessing Elements {#accessing-elements}
Array elements are accessed using their index (starting from 0).
```csharp
Console.WriteLine(numbers[2]); // Output: 30
```
#### Array Length {#array-length}
The Length property returns the number of elements in the array.
```csharp
Console.WriteLine(numbers.Length); // Output: 5
```
### Strings {#strings}
Strings are used to represent text. C# strings are immutable, meaning their value cannot be changed after they are created.
#### String Manipulation {#string-manipulation}
```csharp
string message = "Hello, World!";
Console.WriteLine(message.Length); // Output: 13
Console.WriteLine(message.ToUpper()); // Output: HELLO, WORLD!
Console.WriteLine(message.ToLower()); // Output: hello, world!
Console.WriteLine(message.Substring(0, 5)); // Output: Hello
Console.WriteLine(message.Replace("World", "C#")); // Output: Hello, C#!
```
#### String Interpolation {#string-interpolation}
A convenient way to embed variables and expressions within strings.
```csharp
string name = "Alice";
int age = 30;
string greeting = $"Hello, {name}! You are {age} years old.";
Console.WriteLine(greeting); // Output: Hello, Alice! You are 30 years old.
```
### Methods {#methods}
Methods are blocks of code that perform a specific task. They can accept input parameters and return a value.
#### Method Declaration {#method-declaration}
```csharp
// Method that takes two integers as input and returns their sum
static int Add(int x, int y)
{
return x + y;
}
// Method that takes no input and returns nothing (void)
static void PrintMessage()
{
Console.WriteLine("This is a message.");
}
```
#### Method Calling {#method-calling}
```csharp
int result = Add(5, 3); // Calling the Add method with arguments 5 and 3
Console.WriteLine(result); // Output: 8
PrintMessage(); // Calling the PrintMessage method
```
#### Method Overloading {#method-overloading}
Creating multiple methods with the same name but different parameter lists.
```csharp
static int Add(int x, int y)
{
return x + y;
}
static double Add(double x, double y)
{
return x + y;
}
// Example usage
int sumInt = Add(2, 3); // Calls the first Add method
double sumDouble = Add(2.5, 3.5); // Calls the second Add method
```
## Object-Oriented Programming (OOP) {#object-oriented-programming-(oop)}
C# is an object-oriented programming language, which means it supports the concepts of:
### Classes and Objects {#classes-and-objects}
- **Class**: A blueprint or template for creating objects. It defines the properties (data) and methods (behavior) that objects of that class will have.
- **Object**: An instance of a class. It's a concrete entity that exists in memory.
```csharp
// Define a class named 'Dog'
class Dog
{
// Properties
public string Name { get; set; }
public string Breed { get; set; }
// Method
public void Bark()
{
Console.WriteLine("Woof!");
}
}
// Creating objects of the Dog class
Dog myDog = new Dog();
myDog.Name = "Buddy";
myDog.Breed = "Golden Retriever";
myDog.Bark(); // Output: Woof!
```
### Encapsulation {#encapsulation}
Bundling data (properties) and methods that operate on that data within a class. It hides the internal implementation details of the class from the outside world and provides a controlled way to access and modify the data.
```csharp
class BankAccount
{
private double balance; // Private field to store the balance
public BankAccount(double initialBalance)
{
balance = initialBalance;
}
// Public method to deposit money
public void Deposit(double amount)
{
balance += amount;
}
// Public method to withdraw money
public void Withdraw(double amount)
{
if (amount <= balance)
{
balance -= amount;
}
else
{
Console.WriteLine("Insufficient balance.");
}
}
// Public method to get the balance (read-only)
public double GetBalance()
{
return balance;
}
}
// Usage
BankAccount account = new BankAccount(1000);
account.Deposit(500);
account.Withdraw(200);
Console.WriteLine(account.GetBalance()); // Output: 1300
```
### Inheritance {#inheritance}
A mechanism that allows a class (subclass or derived class) to inherit properties and methods from another class (base class or parent class). It promotes code reuse and establishes an "is-a" relationship between classes.
```csharp
// Base class
class Animal
{
public string Name { get; set; }
public virtual void MakeSound()
{
Console.WriteLine("Generic animal sound");
}
}
// Derived class inheriting from Animal
class Cat: Animal
{
public override void MakeSound()
{
Console.WriteLine("Meow!");
}
}
// Derived class inheriting from Animal
class Dog: Animal
{
public override void MakeSound()
{
Console.WriteLine("Woof!");
}
}
// Usage
Animal animal = new Animal();
animal.MakeSound(); // Output: Generic animal sound
Cat cat = new Cat();
cat.MakeSound(); // Output: Meow!
Dog dog = new Dog();
dog.MakeSound(); // Output: Woof!
```
### Polymorphism {#polymorphism}
The ability of an object to take on many forms. It allows you to treat objects of different classes in a uniform way.
- **Method Overriding**: When a derived class provides a specific implementation for a method that is already defined in its base class. Uses the `virtual` keyword in the base class and the `override` keyword in the derived class. (See example above in Inheritance).
- **Method Overloading**: Creating multiple methods with the same name but different parameter lists. (See example above in Methods).
- **Interface Implementation**: Implementing an interface in a class. (Explained in the Interfaces section).
## Intermediate C# {#intermediate-c#}
### Lists {#lists}
Lists are dynamic arrays that can grow or shrink in size as needed. They are part of the System.Collections.Generic namespace.
#### Creating and Initializing Lists {#creating-and-initializing-lists}
```csharp
using System.Collections.Generic;
List<int> numbers = new List<int>(); // Creates an empty list of integers
List<string> names = new List<string> { "Alice", "Bob", "Charlie" }; // Creates a list with initial values
```
#### Adding and Removing Elements {#adding-and-removing-elements}
```csharp
numbers.Add(10); // Adds 10 to the end of the list
numbers.Add(20);
numbers.Add(30);
numbers.Remove(20); // Removes the first occurrence of 20
numbers.RemoveAt(0); // Removes the element at index 0
```
#### Accessing Elements {#accessing-elements}
```csharp
Console.WriteLine(names[1]); // Output: Bob
```
#### List Properties and Methods {#list-properties-and-methods}
- `Count`: Returns the number of elements in the list.
- `Contains(item)`: Checks if the list contains a specific item.
- `IndexOf(item)`: Returns the index of the first occurrence of a specific item.
- `Clear()`: Removes all elements from the list.
### Dictionaries {#dictionaries}
Dictionaries are used to store key-value pairs. Each key must be unique within the dictionary. Dictionaries are part of the System.Collections.Generic namespace.
#### Creating and Initializing Dictionaries {#creating-and-initializing-dictionaries}
```csharp
using System.Collections.Generic;
Dictionary<string, int> ages = new Dictionary<string, int>(); // Creates an empty dictionary with string keys and integer values
Dictionary<string, string> countries = new Dictionary<string, string>
{
{ "USA", "United States" },
{ "CAN", "Canada" },
{ "GBR", "United Kingdom" }
};
```
#### Adding and Removing Elements {#adding-and-removing-elements}
```csharp
ages.Add("Alice", 30);
ages.Add("Bob", 25);
ages.Remove("Bob"); // Removes the key-value pair with the key "Bob"
```
#### Accessing Elements {#accessing-elements}
```csharp
Console.WriteLine(ages["Alice"]); // Output: 30
```
#### Checking for Keys {#checking-for-keys}
```csharp
if (ages.ContainsKey("Charlie"))
{
Console.WriteLine("Charlie's age is: " + ages["Charlie"]);
}
else
{
Console.WriteLine("Charlie's age is not in the dictionary.");
}
```
#### Dictionary Properties and Methods {#dictionary-properties-and-methods}
- `Count`: Returns the number of key-value pairs in the dictionary.
- `Keys`: Returns a collection of the keys in the dictionary.
- `Values`: Returns a collection of the values in the dictionary.
- `Clear()`: Removes all key-value pairs from the dictionary.
### Exception Handling {#exception-handling}
Exception handling is a mechanism for dealing with errors that occur during program execution.
#### try-catch Block {#try-catch-block}
```csharp
try
{
// Code that might throw an exception
int result = 10 / 0; // This will throw a DivideByZeroException
}
catch (DivideByZeroException ex)
{
// Code to handle the exception
Console.WriteLine("Error: Division by zero.");
Console.WriteLine(ex.Message); // Prints the error message
}
catch (Exception ex)
{
// Catch any other type of exception
Console.WriteLine("An error occurred: " + ex.Message);
}
finally
{
// Code that will always be executed, regardless of whether an exception was thrown or not
Console.WriteLine("Finally block executed.");
}
```
#### throw Statement {#throw-statement}
Used to explicitly throw an exception.
```csharp
static void ValidateAge(int age)
{
if (age < 0)
{
throw new ArgumentException("Age cannot be negative.");
}
Console.WriteLine("Age is valid.");
}
try
{
ValidateAge(-5);
}
catch (ArgumentException ex)
{
Console.WriteLine("Error: " + ex.Message);
}
```
### File I/O {#file-i/o}
File I/O (Input/Output) allows you to read data from and write data to files. Classes for file I/O are in the System.IO namespace.
#### Reading from a File {#reading-from-a-file}
```csharp
using System.IO;
try
{
string filePath = "data.txt";
string content = File.ReadAllText(filePath); // Reads the entire file content into a string
Console.WriteLine(content);
}
catch (FileNotFoundException)
{
Console.WriteLine("File not found.");
}
catch (IOException ex)
{
Console.WriteLine("An error occurred while reading the file: " + ex.Message);
}
```
#### Writing to a File {#writing-to-a-file}
```csharp
using System.IO;
try
{
string filePath = "output.txt";
string content = "This is some text to write to the file.";
File.WriteAllText(filePath, content); // Writes the content to the file
Console.WriteLine("Data written to file.");
}
```
catch (IOException ex)
{
Console.WriteLine("An error occurred while writing to the file: " + ex.Message);
}
```
#### Using StreamReader and StreamWriter {#using-streamreader-and-streamwriter}
Provides more control over reading and writing.
```csharp
using System.IO;
try
{
// Writing to a file using StreamWriter
using (StreamWriter writer = new StreamWriter("log.txt", true)) // 'true' for appending to the file
{
writer.WriteLine(DateTime.Now + ": Log entry");
}
// Reading from a file using StreamReader
using (StreamReader reader = new StreamReader("log.txt"))
{
string line;
while ((line = reader.ReadLine())!= null)
{
Console.WriteLine(line);
}
}
}
catch (IOException ex)
{
Console.WriteLine("An error occurred: " + ex.Message);
}
```
### Delegates and Events {#delegates-and-events}
#### Delegates {#delegates}
Type-safe function pointers. They allow you to pass methods as arguments to other methods.
```csharp
// Define a delegate that takes an integer and returns a string
delegate string StringModifier(int number);
class Program
{
// Method that matches the delegate's signature
static string NumberToString(int num)
{
return "Number: " + num;
}
static void Main(string[] args)
{
// Create an instance of the delegate, pointing to the NumberToString method
StringModifier modifier = new StringModifier(NumberToString);
// Invoke the delegate
string result = modifier(10);
Console.WriteLine(result); // Output: Number: 10
}
}
```
#### Events {#events}
A mechanism for a class to notify other classes when something of interest happens. They are based on delegates.
```csharp
// Define a delegate for the event
delegate void ValueChangedEventHandler(int newValue);
class Counter
{
private int value;
// Declare an event based on the delegate
public event ValueChangedEventHandler ValueChanged;
public int Value
{
get { return value; }
set
{
if (this.value!= value)
{
this.value = value;
// Raise the event
ValueChanged?.Invoke(value); // Use the null-conditional operator to check if the event is null
}
}
}
}
class Program
{
// Event handler method
static void Counter_ValueChanged(int newValue)
{
Console.WriteLine("Value changed to: " + newValue);
}
static void Main(string[] args)
{
Counter counter = new Counter();
// Subscribe to the event
counter.ValueChanged += Counter_ValueChanged;
// Change the value, which will raise the event
counter.Value = 5; // Output: Value changed to: 5
counter.Value = 10; // Output: Value changed to: 10
}
}
```
### LINQ (Language Integrated Query) {#linq-(language-integrated-query)}
LINQ provides a unified way to query data from various sources, such as collections, databases, and XML files. It uses a SQL-like syntax to filter, sort, and group data.
#### LINQ to Objects {#linq-to-objects}
Querying in-memory collections.
```csharp
using System.Linq;
List<int> numbers = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
// Use LINQ to filter even numbers
IEnumerable<int> evenNumbers = from num in numbers
where num % 2 == 0
select num;
// Using lambda expression syntax
IEnumerable<int> oddNumbers = numbers.Where(num => num % 2!= 0);
// Print the results
Console.WriteLine("Even numbers:");
foreach (int num in evenNumbers)
{
Console.WriteLine(num);
}
Console.WriteLine("Odd numbers:");
foreach (int num in oddNumbers)
{
Console.WriteLine(num);
}
```
#### Common LINQ Operators {#common-linq-operators}
- `Where()`: Filters a sequence based on a predicate.
- `Select()`: Projects each element of a sequence into a new form.
- `OrderBy()`: Sorts the elements of a sequence in ascending order.
- `OrderByDescending()`: Sorts the elements of a sequence in descending order.
- `GroupBy()`: Groups the elements of a sequence based on a key.
- `Join()`: Joins two sequences based on a matching key.
- `Count()`: Returns the number of elements in a sequence.
- `Sum()`: Computes the sum of the elements in a sequence.
- `Average()`: Computes the average of the elements in a sequence.
- `Min()`: Returns the minimum value in a sequence.
- `Max()`: Returns the maximum value in a sequence.
- `First()`: Returns the first element of a sequence.
- `FirstOrDefault()`: Returns the first element of a sequence, or a default value if the sequence is empty.
- `Single()`: Returns the only element of a sequence, and throws an exception if the sequence contains more than one element or is empty.
- `SingleOrDefault()`: Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.
- `Any()`: Determines whether any element of a sequence satisfies a condition.
- `All()`: Determines whether all elements of a sequence satisfy a condition.
### Asynchronous Programming (async/await) {#asynchronous-programming-(async/await)}
Asynchronous programming allows you to perform long-running operations without blocking the main thread, which keeps the UI responsive. It uses the async and await keywords.
#### async and await {#async-and-await}
```csharp
using System;
using System.Net.Http;
using System.Threading.Tasks;
class Program
{
static async Task Main(string[] args)
{
Console.WriteLine("Starting...");
string content = await DownloadContentAsync("https://www.example.com");
Console.WriteLine("Content downloaded.");
Console.WriteLine(content.Substring(0, 100)); // Print the first 100 characters
Console.WriteLine("Finished.");
}
static async Task<string> DownloadContentAsync(string url)
{
using (HttpClient client = new HttpClient())
{
HttpResponseMessage response = await client.GetAsync(url);
response.EnsureSuccessStatusCode(); // Throw exception if status code is not success
return await response.Content.ReadAsStringAsync();
}
}
}
```
#### Task and Task<T> {#task-and-task<t>}
- **Task**: Represents an asynchronous operation that doesn't return a value.
- **Task<T>**: Represents an asynchronous operation that returns a value of type T.
## Advanced C# {#advanced-c#}
### Attributes {#attributes}
Attributes are metadata that can be added to code elements (e.g., classes, methods, properties) to provide additional information about them. Attributes are used for various purposes, such as:
- Providing information to the compiler.
- Enabling runtime behavior.
- Generating documentation.
```csharp
// Define a custom attribute
[AttributeUsage(AttributeTargets.Class | AttributeTargets.Method, AllowMultiple = false)]
public class AuthorAttribute: Attribute
{
public string Name { get; set; }
public string Version { get; set; }
public AuthorAttribute(string name)
{
Name = name;
Version = "1.0"; // Default version
}
}
```
```csharp
// Apply the attribute to a class
[Author("John Doe", Version = "2.0")]
public class MyClass
{
// Apply the attribute to a method
[Author("Jane Smith")]
public void MyMethod()
{
Console.WriteLine("MyMethod executed.");
}
}
class Program
{
static void Main(string[] args)
{
// Use reflection to get the attribute information
Type type = typeof(MyClass);
AuthorAttribute classAuthor = (AuthorAttribute)Attribute.GetCustomAttribute(type, typeof(AuthorAttribute));
if (classAuthor!= null)
{
Console.WriteLine("Class Author: " + classAuthor.Name);
Console.WriteLine("Class Version: " + classAuthor.Version);
}
System.Reflection.MethodInfo method = type.GetMethod("MyMethod");
AuthorAttribute methodAuthor = (AuthorAttribute)Attribute.GetCustomAttribute(method, typeof(AuthorAttribute));
if (methodAuthor!= null)
{
Console.WriteLine("Method Author: " + methodAuthor.Name);
Console.WriteLine("Method Version: " + methodAuthor.Version); // Will output default version if not specified in the attribute
}
}
}
```
### Reflection {#reflection}
Reflection allows you to inspect and manipulate types, objects, and assemblies at runtime. It's a powerful technique, but it can also be complex and impact performance.
```csharp
using System;
using System.Reflection;
class Person
{
public string Name { get; set; }
public int Age { get; set; }
public void PrintDetails()
{
Console.WriteLine($"Name: {Name}, Age: {Age}");
}
}
class Program
{
static void Main(string[] args)
{
// Get the type information for the Person class
Type personType = typeof(Person);
// Create an instance of the Person class using reflection
object personInstance = Activator.CreateInstance(personType);
// Get the Name property and set its value
PropertyInfo nameProperty = personType.GetProperty("Name");
nameProperty.SetValue(personInstance, "Alice");
// Get the Age property and set its value
PropertyInfo ageProperty = personType.GetProperty("Age");
ageProperty.SetValue(personInstance, 30);
// Get the PrintDetails method and invoke it
MethodInfo printDetailsMethod = personType.GetMethod("PrintDetails");
printDetailsMethod.Invoke(personInstance, null); // Output: Name: Alice, Age: 30
}
}
```
### Generics {#generics}
Generics allow you to write code that can work with different data types without having to write separate code for each type. They provide type safety and code reusability.
#### Generic Classes {#generic-classes}
```csharp
// Generic class that can store a value of any type
class DataHolder<T>
{
public T Data { get; set; }
}
// Usage
DataHolder<int> intHolder = new DataHolder<int>();
intHolder.Data = 10;
DataHolder<string> stringHolder = new DataHolder<string>();
stringHolder.Data = "Hello";
```
#### Generic Methods {#generic-methods}
```csharp
// Generic method that can print an array of any type
static void PrintArray<T>(T[] array)
{
foreach (T element in array)
{
Console.WriteLine(element);
}
}
// Usage
int[] numbers = { 1, 2, 3, 4, 5 };
PrintArray(numbers);
string[] names = { "Alice", "Bob", "Charlie" };
PrintArray(names);
```
#### Generic Constraints {#generic-constraints}
Used to restrict the types that can be used with a generic type parameter.
```csharp
// Generic method with a constraint that the type must be a class
static void PrintName<T>(T obj) where T: class
{
Console.WriteLine(obj.GetType().Name);
}
// Generic method with a constraint that the type must implement an interface
interface IPrintable
{
void Print();
}
class MyClass: IPrintable
{
public void Print()
{
Console.WriteLine("MyClass");
}
}
static void PrintObject<T>(T obj) where T: IPrintable
{
obj.Print();
}
```
### Unsafe Code and Pointers {#unsafe-code-and-pointers}
C# allows you to write "unsafe" code, which can directly manipulate memory using pointers. This is typically used for performance-critical sections of code or when interacting with native libraries. Unsafe code requires the unsafe keyword.
```csharp
unsafe class Program
{
static void Main(string[] args)
{
int number = 10;
// Declare a pointer to the integer
int* ptr = &number;
// Access the value through the pointer
Console.WriteLine($"Value: {*ptr}");
Console.WriteLine($"Address: {(long)ptr}");
// Modify the value through the pointer
*ptr = 20;
Console.WriteLine($"Modified value: {number}");
}
}
```
# Linux from Basics to Advanced

## Introduction to Linux
Linux is an open-source operating system kernel that forms the base of numerous operating systems, often referred to as Linux distributions (distros). 
Its flexibility, security, and customizability make it a powerful choice for servers, desktops, embedded systems, and more. 
This guide provides a deep dive into Linux, covering everything from basic concepts to advanced system administration.

## Getting Started with Linux

### Choosing a Distribution
The first step is selecting a distribution. 
Popular options include:
- **Ubuntu**: User-friendly, great for beginners, with a large community.
- **Debian**: Stable and reliable, the basis for many other distributions.
- **Fedora**: Cutting-edge, focuses on free and open-source software.
- **CentOS Stream/Rocky Linux/AlmaLinux**: Enterprise-grade, commonly used on servers (Rebuilt from RHEL Source).
- **Arch Linux**: Highly customizable, for experienced users.
Consider your experience level and intended use when making your choice.

### Installation
Installation methods vary. Most distributions offer bootable ISO images that can be burned to a USB drive. Booting from the USB drive allows you to install the OS on your hard drive.
1. **Download the ISO**: Get the ISO image from the distribution's website.

2. **Create a Bootable USB**: Use tools like dd (Linux), Rufus (Windows), or Etcher to create a bootable USB drive.
```bash
# Example using dd (replace /path/to/your/iso and /dev/sdX)
sudo dd bs=4M if=/path/to/your/iso of=/dev/sdX status=progress oflag=sync
```
**Important**: Be very careful with dd, as using the wrong device can overwrite your hard drive.

3. **Boot from USB**: Restart your computer and enter the BIOS/UEFI settings (usually by pressing Delete, F2, or F12 during startup). 
Change the boot order to prioritize the USB drive.

4. **Follow the Installer**: The installation process is usually guided by a graphical interface. 
Choose your language, keyboard layout, time zone, and create a user account. During partition step, new users should let the installer configure the disk.
More advanced users can create partitions manually.

For Example:
- **/**: The root partition (where the OS is installed). Allocate at least 20GB.
- **/home**: User data. Allocate most of remaining space.
- **/swap**: Swap space (used for virtual memory). Typically, allocate the same amount of RAM.

5. **Complete the Installation**: Once the installation is finished, reboot your computer. Remove the USB drive when prompted.
### The GUI Environment {#the-gui-environment}
Most distributions default to a graphical user interface (GUI). Popular choices include:
- **GNOME**: A modern and user-friendly desktop environment.
- **KDE Plasma**: Highly customizable and feature-rich.
- **XFCE**: Lightweight and efficient, suitable for older hardware.

You can interact with the OS using the mouse, keyboard, and graphical applications. 
Explore the desktop environment to familiarize yourself with its features.

## Command Line Interface (CLI) 
The CLI is a powerful tool for interacting with Linux. 
- It provides granular control over the system.

### Basic Commands
- **pwd**: Print working directory. Shows the current directory.
- **cd**: Change directory. Navigates the file system.
- `cd..`: Go up one directory.
- `cd ~`: Go to the home directory.
- `cd /`: Go to the root directory.
- **ls**: List directory contents.
- `ls -l`: Long listing format, providing details like permissions, owner, size, and modification date.
- `ls -a`: Show all files, including hidden files (starting with a dot).
- `ls -h`: Display sizes in human-readable format (e.g., KB, MB, GB).
- `ls -t`: Sort by modification time (newest first).
- **mkdir**: Create directory.

```bash
mkdir new_directory
```
- **rmdir**: Remove directory (empty).

```bash
rmdir empty_directory
```

- **touch**: Create an empty file or update the timestamp of an existing file.
```bash
touch new_file.txt
```

**rm**: Remove file or directory.
- `rm file.txt`: Remove a file.
- `rm -r directory`: Remove a directory and its contents recursively (use with caution!).
- `rm -f file.txt`: Force remove a file, even if you don't have write permissions.
- **cp**: Copy file or directory.

```bash
cp file.txt new_location.txt
cp -r directory new_directory
```

**mv**: Move or rename file or directory.
```bash
mv file.txt new_name.txt
mv file.txt /new/location/
```

**cat**: Concatenate and display file contents.
```bash
cat file.txt
```

**less**: View file contents page by page. Press q to quit.
```bash
less large_file.txt
```

**head**: Display the first few lines of a file (default: 10 lines).
```bash
head file.txt
head -n 20 file.txt # Display the first 20 lines
```

**tail**: Display the last few lines of a file (default: 10 lines). Useful for monitoring log files.
```bash
tail file.txt
tail -f log_file.txt # Follow the log file in real-time
```

**echo**: Display text.
```bash
echo "Hello, world!"
echo $PATH # Display the value of the PATH environment variable
```

**man**: Display the manual page for a command.
```bash
man ls
```

**history**: Show the command history.
- `!n`: Execute the nth command in the history.
- `!!`: Execute the last command.
- `Ctrl+r`: Reverse search the command history.

### File Permissions
Linux file permissions control who can access and modify files and directories. 
Permissions are represented by three sets of three characters: rwx for the owner, group, and others.
- **r**: Read permission.
- **w**: Write permission.
- **x**: Execute permission (for files) or enter/search permission (for directories).

Use `ls -l` to view permissions. For example: `-rwxr-xr-- 1 user group file.txt`
The first character indicates the file type: `-` (regular file), `d` (directory), `l` (symbolic link), etc.
- The next three characters (rwx) are the owner's permissions.
- The next three characters (r-x) are the group's permissions.
- The last three characters (r--) are the permissions for others.

Use `chmod` to change permissions.
**Symbolic mode:**
- `chmod u+x file.txt`: Add execute permission for the owner.
- `chmod g-w file.txt`: Remove write permission for the group.
- `chmod o=r file.txt`: Set read-only permission for others.
  
**Numeric mode:** Permissions are represented by octal numbers. 4 for read, 2 for write, 1 for execute.
  Add the numbers together to get the permission value.
- `7 (rwx)`: 4 + 2 + 1
- `6 (rw-)`: 4 + 2 + 0
- `5 (r-x)`: 4 + 0 + 1
- `4 (r--)`: 4 + 0 + 0
- `chmod 755 file.txt`: Set rwx for the owner, r-x for the group, and r-x for others.
- `chmod 644 file.txt`: Set rw- for the owner, r-- for the group, and r-- for others.

Use `chown` to change the owner and group of a file.
```bash
sudo chown user:group file.txt
```
## Package Management
Package managers are essential for installing, updating, and removing software.
### Debian/Ubuntu (APT):
- `sudo apt update`: Update the package list.
- `sudo apt upgrade`: Upgrade installed packages.
- `sudo apt install package_name`: Install a package.
- `sudo apt remove package_name`: Remove a package.
- `sudo apt purge package_name`: Remove a package and its configuration files.
- `apt search keyword`: Search for packages.

### Fedora/CentOS/RHEL (DNF/YUM):
- `sudo dnf update`: Update the package list and upgrade installed packages.
- `sudo dnf install package_name`: Install a package.
- `sudo dnf remove package_name`: Remove a package.
- `dnf search keyword`: Search for packages.
### Arch Linux (Pacman): {#arch-linux-(pacman):}
- `sudo pacman -Syu`: Synchronize package databases and upgrade installed packages.
- `sudo pacman -S package_name`: Install a package.
- `sudo pacman -R package_name`: Remove a package.
- `pacman -Ss keyword`: Search for packages.
## Redirection and Piping {#redirection-and-piping}
Redirection allows you to redirect the input and output of commands. Piping allows you to chain commands together.
- **>**: Redirect output to a file (overwrites the file).
```bash
ls -l > file_list.txt
```
- **>>**: Redirect output to a file (appends to the file).
```bash
echo "New entry" >> file_list.txt
```
- **<**: Redirect input from a file.
```bash
mail -s "Subject" user@example.com < message.txt
```
- **|**: Pipe the output of one command to the input of another.
```bash
ls -l | grep "file.txt" # List files and filter for "file.txt"
cat file.txt | less # View a large file page by page
```
## Text Processing Tools
**grep**: Search for patterns in files.
- `grep "pattern" file.txt`: Search for "pattern" in "file.txt".
- `grep -i "pattern" file.txt`: Case-insensitive search.
- `grep -r "pattern" directory`: Recursive search in a directory.

**sed**: Stream editor for text manipulation.
- `sed 's/old/new/g' file.txt`: Replace all occurrences of "old" with "new" in "file.txt".
- `sed -i 's/old/new/g' file.txt`: Replace in-place (modifies the original file).

**awk**: Pattern scanning and processing language.
- `awk '{print $1}' file.txt`: Print the first field of each line in "file.txt" (fields are separated by whitespace by default).
- `awk -F',' '{print $2}' file.csv`: Print the second field of each line in "file.csv" (fields are separated by commas).

## Networking Commands
- **ping**: Test network connectivity.
```bash
ping google.com
```
- **ifconfig** or **ip addr**: Display network interface information. `ip addr` is the modern replacement for `ifconfig`.
```bash
ip addr
```
- **netstat** or **ss**: Display network connections, routing tables, and interface statistics. `ss` is the modern replacement for `netstat`.
```bash
ss -tulnp
```
- **ssh**: Secure Shell for remote access.
```bash
ssh user@remote_host
```
- **scp**: Secure copy for transferring files.
```bash
scp file.txt user@remote_host:/path/to/destination/
```
- **wget**: Download files from the web.
```bash
wget https://example.com/file.txt
```
- **curl**: Transfer data from or to a server.
```bash
curl https://example.com
```
- **traceroute**: Trace the route packets take to a host.
```bash
traceroute google.com
```
- **nslookup**: Query DNS servers.
```bash
nslookup google.com
```

## Process Management
- **ps**: Display running processes.
- `ps aux`: Display all processes with detailed information.
- `ps -ef`: Display all processes with full command lines.
- **top**: Display a dynamic real-time view of running processes.
- **htop**: An interactive process viewer (needs to be installed).
- **kill**: Terminate a process.
```bash
kill process_id
kill -9 process_id # Forcefully kill a process
```
- **pkill**: Kill processes by name.
```bash
pkill process_name
```
- **nice**: Run a process with a modified priority.
```bash
nice -n 10 command # Run command with a lower priority
```
- **renice**: Change the priority of a running process.
```bash
renice -n 10 process_id
```
- **bg**: Move a process to the background.
- **fg**: Move a process to the foreground.
- **jobs**: List background jobs.

## System Information
- **uname -a**: Display kernel information.
- **hostname**: Display the hostname.
- **uptime**: Display how long the system has been running.
- **free -m**: Display memory usage in megabytes.
- **df -h**: Display disk space usage in human-readable format.
- **du -hsx * | sort -rh | head -10**: List the top 10 largest directories in the current directory.
- **lscpu**: Display CPU information.
- **lspci**: Display PCI device information.
- **lsusb**: Display USB device information.

## Shell Scripting
Shell scripting allows you to automate tasks by writing scripts that execute a series of commands.

### Basic Script Structure
1. **Create a Script**: Create a file with a.sh extension (`my_script.sh`).
2. **Shebang**: Start the script with a shebang line to specify the interpreter (usually `#!/bin/bash`).
3. **Commands**: Add commands to the script.
4. **Make Executable**: Use `chmod +x my_script.sh` to make the script executable.
5. **Run the Script**: Execute the script using `./my_script.sh`.

### Example Script
```bash
#!/bin/bash {#binbash}
# This is a comment {#this-is-a-comment}
echo "Hello, world!"
# Create a directory {#create-a-directory}
mkdir my_directory
# List the contents of the directory {#list-the-contents-of-the-directory}
ls -l my_directory
```

### Variables
```bash
NAME="John Doe"
echo "Hello, $NAME"
```

### Conditional Statements
```bash
if [ $NAME == "John Doe" ]; then
echo "Name is John Doe"
else
echo "Name is not John Doe"
fi
```

### Loops
```bash
for i in 1 2 3 4 5; do
echo "Number: $i"
done
```

### Functions
```bash
my_function() {
echo "This is a function"
}
my_function
```

## System Administration
### User and Group Management
- **useradd**: Create a new user.
```bash
sudo useradd newuser
sudo passwd newuser # Set the password for the new user
```
- **userdel**: Delete a user.
```bash
sudo userdel -r newuser # -r removes the home directory
```
- **usermod**: Modify a user account.
```bash
sudo usermod -aG sudo newuser # Add newuser to the sudo group
```
- **groupadd**: Create a new group.
```bash
sudo groupadd newgroup
```
- **groupdel**: Delete a group.
```bash
sudo groupdel newgroup
```
- **gpasswd**: Administer groups.
```bash
sudo gpasswd -a user group # Add user to group
sudo gpasswd -d user group # Remove user from group
```
- **id**: Display user and group information.

### Service Management
Systemd is the system and service manager in most modern Linux distributions.
- `systemctl start service_name`: Start a service.
- `systemctl stop service_name`: Stop a service.
- `systemctl restart service_name`: Restart a service.
- `systemctl status service_name`: Check the status of a service.
- `systemctl enable service_name`: Enable a service to start at boot.
- `systemctl disable service_name`: Disable a service from starting at boot.
- `systemctl is-enabled service_name`: Check if a service is enabled.
- `journalctl -u service_name`: View the logs for a service.

### Log Management
Linux systems generate logs that are crucial for troubleshooting and security auditing.

**Log Files and Tools:**
- `/var/log`: The main directory for log files
- `journalctl`: Query the systemd journal (centralized logging system)

**Common journalctl Commands:**
- `journalctl -xe`: View logs with explanations and extra context
- `journalctl -f`: Follow the logs in real-time
- `journalctl -b`: View logs from the current boot
- `journalctl --since "yesterday"`: View logs from yesterday
- `journalctl --until "today"`: View logs until today

**Additional Tools:**
- `dmesg`: Display kernel messages (useful for hardware issues)
- `logrotate`: A utility for managing log files (rotating, compressing, and deleting old logs)
- Configuration files are typically located in `/etc/logrotate.d/`

### Task Scheduling (Cron)
Cron allows you to schedule tasks to run automatically at specific times.

**Basic Crontab Commands:**
- `crontab -e`: Edit the crontab file
- `crontab -l`: List the crontab entries
- `crontab -r`: Remove the crontab

**Crontab Syntax:**
```
minute hour day_of_month month day_of_week command
```

**Common Examples:**
- `0 0 * * * /path/to/script.sh`: Run the script every day at midnight
- `0 12 * * 1 /path/to/script.sh`: Run the script every Monday at noon
- `*/5 * * * * /path/to/script.sh`: Run the script every 5 minutes

### Backup and Restore
Regular backups are crucial for data protection.

##### tar (Tape Archive)
- A common tool for archiving files:
```bash
```
##### Create a tar archive
```bash
tar -cvf backup.tar /path/to/directory
```
##### Extract a tar archive
```bash
tar -xvf backup.tar
```
##### Create a compressed tar archive (gzip)
```bash
tar -czvf backup.tar.gz /path/to/directory
```
##### Extract a compressed tar archive (gzip)
```bash
tar -xzvf backup.tar.gz
```
##### Create a compressed tar archive (bzip2) 
```bash
tar -cjvf backup.tar.bz2 /path/to/directory
```
##### Extract a compressed tar archive (bzip2)
```bash
tar -xjvf backup.tar.bz2
```

#### rsync (Remote Sync) 
- A powerful tool for synchronizing files and directories:

#### Local sync
```bash
rsync -av /path/to/source/ /path/to/destination/
```
#### Remote sync
```bash
rsync -av user@remote_host:/path/to/source/ /path/to/destination/
```
Options:
- a: archive mode (preserves permissions, timestamps, etc.)
- v: verbose
- z: compress data during transfer
- r: recursive

### Performance Monitoring 
#### System Resource Monitoring 
- **top/htop**: Real-time process monitoring
- **vmstat**: Virtual memory statistics
- **iostat**: I/O statistics
- **sar**: System activity reporter (collects and reports system activity data)
- **free -m**: Memory usage
- **df -h**: Disk space usage
- **iotop**: I/O monitoring (needs to be installed)
  
### Security
#### User Authentication
- **Password Policies**: Enforce strong password requirements

**Multi-factor authentication (MFA)**: Implement MFA for enhanced security. 
Tools like Google Authenticator or Authy can be used with PAM (Pluggable Authentication Modules).

#### SSH Authentication
- Disable password-based SSH authentication and use SSH keys instead
- Steps:

#### Generate SSH key pair on client machine
```bash
ssh-keygen -t rsa -b 4096
```
#### Copy public key to server
```bash
ssh-copy-id user@remote_host
```
#### Disable password authentication on server 

### Edit /etc/ssh/sshd_config: PasswordAuthentication no
#### Restart SSH service
```bash
sudo systemctl restart sshd
```

#### Firewall Configuration
- Firewalls control network traffic in and out of the system

### iptables (Traditional Firewall)
##### List current rules 
```bash
iptables -L
```
##### Allow SSH traffic
```bash
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
```
##### Block HTTP traffic
```bash
iptables -A INPUT -p tcp --dport 80 -j DROP
```

### nftables (Modern Firewall)
##### List current rules
```bash
nft list ruleset
```
##### Allow SSH traffic
```bash
nft add rule inet filter input tcp dport 22 accept
```
###### Block HTTP traffic 
```bash
nft add rule inet filter input tcp dport 80 drop
```

### UFW (Uncomplicated Firewall) Common in Ubuntu/Debian systems:
#### Enable and check firewall
```
ufw enable
ufw status
```
# Configure rules
```
ufw allow 22/tcp # Allow SSH traffic
ufw deny 80/tcp # Block HTTP traffic
```
Intrusion Detection Systems (IDS)
IDS monitor network traffic and system activity for malicious behavior.

### Network-based IDS
- **Snort**: A popular network IDS
#### Install Snort
```bash
sudo apt install snort
```
#### Check Snort configuration
```bash
sudo snort -T -c /etc/snort/snort.conf
```

### Host-based IDS
- **Tripwire**: File integrity monitoring
#### Initialize database
```
sudo tripwire --init
```
#### Check for changes
```
sudo tripwire --check
```
- **AIDE** (Advanced Intrusion Detection Environment)
#### Install AIDE
```bash
sudo apt install aide
```
#### Initialize database
```bash
sudo aideinit
```
#### Check for changes
```bash
sudo aide --check
```

---
## Security Auditing
Regularly audit system logs and system activity for security monitoring.
### System Logs 
- **Authentication Logs**: `/var/log/auth.log` or `/var/log/secure`
- **System Logs**: `/var/log/syslog` or `/var/log/messages`
- **Kernel Logs**: `/var/log/kern.log`

#### User Activity Monitoring
```bash
# Show last logged in users {#show-last-logged-in-users}
last
# Show current user sessions and activity {#show-current-user-sessions-and-activity}
w
# Show logged in users {#show-logged-in-users}
who
```

#### Network Activity Monitoring
```bash
# Show listening ports (traditional) {#show-listening-ports-traditional}
netstat -tuln
# Show listening ports (modern) {#show-listening-ports-modern}
ss -tuln
# List open network files {#list-open-network-files}
lsof -i
```

### Rootkit Detection
- Rootkits are malicious software that hide their presence and grant unauthorized access.

#### Rootkit Detection
Rootkits are malicious software that hide their presence and grant unauthorized access.
##### Detection Tools
### **rkhunter** (Rootkit Hunter)
```bash
# Install rkhunter {#install-rkhunter}
sudo apt install rkhunter
# Update the database {#update-the-database}
sudo rkhunter --update
# Perform a system check {#perform-a-system-check}
sudo rkhunter --check
```
### **chkrootkit**
```bash
# Install chkrootkit {#install-chkrootkit}
sudo apt install chkrootkit
# Run system scan {#run-system-scan}
sudo chkrootkit
```

### Best Practices
- Run rootkit scans regularly as part of security maintenance
- Keep detection tools updated
- Investigate any suspicious findings immediately
- Maintain system backups in case of compromise

---
### SELinux/AppArmor
These are Mandatory Access Control (MAC) systems that provide an extra layer of security by defining policies that restrict what processes can do.

### SELinux/AppArmor
Mandatory Access Control (MAC) systems that provide an extra layer of security by defining policies that restrict what processes can do.
##### SELinux Management
```bash
# Check SELinux status {#check-selinux-status}
getenforce
# Set SELinux mode (0=permissive, 1=enforcing) {#set-selinux-mode-0permissive-1enforcing}
setenforce 1
# Set SELinux boolean values {#set-selinux-boolean-values}
setsebool -P httpd_can_network_connect on
```

##### AppArmor Management
```bash
# Check AppArmor status {#check-apparmor-status}
aa-status
# Set a profile to enforce mode {#set-a-profile-to-enforce-mode}
aa-enforce /etc/apparmor.d/profile_name
# Set a profile to complain mode {#set-a-profile-to-complain-mode}
aa-complain /etc/apparmor.d/profile_name
```

### Best Practices
- Always test policy changes in permissive mode first
- Monitor system logs for policy violations
- Keep policies updated with system changes
- Document custom policy modifications

## Virtualization
Virtualization allows you to run multiple operating systems on a single physical machine.

### Virtualization Platforms
- **VirtualBox**
- Open-source virtualization platform
- User-friendly interface
- Supports most operating systems
- **KVM** (Kernel-based Virtual Machine)
```bash
# Install KVM and required packages
sudo apt install qemu-kvm libvirt-daemon-system
```
#### Add user to required groups
```bash
sudo usermod -aG libvirt $USER
sudo usermod -aG kvm $USER
```
#### Launch virtual machine manager 
virt-manager
```
- **VMware**
- Commercial virtualization platform
- Enterprise-grade features
- Professional support available
```
#### Container Virtualization
- **Docker**
```bash
# Pull an image
docker pull ubuntu:latest
# Run a container 
docker run -it ubuntu:latest
# List running containers
docker ps
```

#### Best Practices
- Regular backups of virtual machines
- Monitor resource usage
- Keep virtualization software updated
- Use snapshots before major changes
  
### Advanced Topics 
#### Kernel Compilation
Compiling the Linux kernel allows you to customize the kernel to your specific hardware and software needs.
```bash
# Download and extract kernel source
wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.x.tar.xz
tar xf linux-5.x.tar.xz
cd linux-5.x
# Configure kernel 
make menuconfig
# Compile kernel
make -j$(nproc)
# Install modules and kernel
sudo make modules_install
sudo make install
```
#### LVM (Logical Volume Management) {#lvm-(logical-volume-management)}
LVM allows you to manage disk space flexibly.
```bash
# Create physical volume
pvcreate /dev/sda1
# Create volume group
vgcreate myvg /dev/sda1
# Create and format logical volume
lvcreate -L 10G -n mylv myvg
mkfs.ext4 /dev/myvg/mylv
# Mount logical volume
mount /dev/myvg/mylv /mnt
# Resize logical volume
lvresize -L +5G /dev/myvg/mylv
resize2fs /dev/myvg/mylv
```
### System Tuning
#### Kernel Parameter Management
```bash
# List all kernel parameters
sysctl -a
# Set a kernel parameter
sysctl -w vm.swappiness=60
# Make changes persistent
echo "vm.swappiness=60" >> /etc/sysctl.conf
sysctl -p
```

##### Process Priority Management
```bash
# Start a process with lower priority
nice -n 10 command
# Change priority of running process
renice -n 10 -p process_id
# Set resource limits
ulimit -n 4096 # Set maximum number of open files
```

##### System Optimization
- **tuned**: Daemon for system tuning
```bash
# Install tuned
sudo apt install tuned
# List available profiles
tuned-adm list
# Apply a profile
tuned-adm profile balanced
```
### System Profiling
#### Performance Monitoring
- **top/htop**: Real-time system monitoring
- **sar**: System activity reporter
- **iotop**: I/O monitoring
- 
#### Advanced Analysis Tools
```bash
# Trace system calls
strace command
# Profile CPU performance
perf record command
perf report
# Trace kernel functions
ftrace
```
##### Best Practices
- Regular performance monitoring
- Baseline performance metrics
- Document system changes
- Test changes in staging environment
---

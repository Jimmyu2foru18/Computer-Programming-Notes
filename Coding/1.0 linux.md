# Linux from Basics to Advanced {#linux-from-basics-to-advanced}
## Introduction to Linux {#introduction-to-linux}
Linux is an open-source operating system kernel that forms the base of numerous operating systems, often referred to as Linux distributions (distros). Its flexibility, security, and customizability make it a powerful choice for servers, desktops, embedded systems, and more. This guide provides a deep dive into Linux, covering everything from basic concepts to advanced system administration.
## Getting Started with Linux {#getting-started-with-linux}
### Choosing a Distribution {#choosing-a-distribution}
The first step is selecting a distribution. Popular options include:
- **Ubuntu**: User-friendly, great for beginners, with a large community.
- **Debian**: Stable and reliable, the basis for many other distributions.
- **Fedora**: Cutting-edge, focuses on free and open-source software.
- **CentOS Stream/Rocky Linux/AlmaLinux**: Enterprise-grade, commonly used on servers (Rebuilt from RHEL Source).
- **Arch Linux**: Highly customizable, for experienced users.
Consider your experience level and intended use when making your choice.
### Installation {#installation}
Installation methods vary. Most distributions offer bootable ISO images that can be burned to a USB drive. Booting from the USB drive allows you to install the OS on your hard drive.
1. **Download the ISO**: Get the ISO image from the distribution's website.
2. **Create a Bootable USB**: Use tools like dd (Linux), Rufus (Windows), or Etcher to create a bootable USB drive.
```bash
# Example using dd (replace /path/to/your/iso and /dev/sdX) {#example-using-dd-replace-pathtoyouriso-and-devsdx}
sudo dd bs=4M if=/path/to/your/iso of=/dev/sdX status=progress oflag=sync
```
**Important**: Be very careful with dd, as using the wrong device can overwrite your hard drive.
3. **Boot from USB**: Restart your computer and enter the BIOS/UEFI settings (usually by pressing Delete, F2, or F12 during startup). Change the boot order to prioritize the USB drive.
4. **Follow the Installer**: The installation process is usually guided by a graphical interface. Choose your language, keyboard layout, time zone, and create a user account. During partition step, new users should let the installer configure the disk. More advanced users can create partitions manually. For example:
- **/**: The root partition (where the OS is installed). Allocate at least 20GB.
- **/home**: User data. Allocate most of remaining space.
- **/swap**: Swap space (used for virtual memory). Typically, allocate the same amount of RAM.
5. **Complete the Installation**: Once the installation is finished, reboot your computer. Remove the USB drive when prompted.
### The GUI Environment {#the-gui-environment}
Most distributions default to a graphical user interface (GUI). Popular choices include:
- **GNOME**: A modern and user-friendly desktop environment.
- **KDE Plasma**: Highly customizable and feature-rich.
- **XFCE**: Lightweight and efficient, suitable for older hardware.
You can interact with the OS using the mouse, keyboard, and graphical applications. Explore the desktop environment to familiarize yourself with its features.
## Command Line Interface (CLI) Mastery {#command-line-interface-(cli)-mastery}
The CLI is a powerful tool for interacting with Linux. It provides granular control over the system.
### Basic Commands {#basic-commands}
- **pwd**: Print working directory. Shows the current directory.
- **cd**: Change directory. Navigates the file system.
- `cd..`: Go up one directory.
- `cd ~`: Go to the home directory.
- `cd /`: Go to the root directory.
- **ls**: List directory contents.
- `ls -l`: Long listing format, providing details like permissions, owner, size, and modification date.
- `ls -a`: Show all files, including hidden files (starting with a dot).
- `ls -h`: Display sizes in human-readable format (e.g., KB, MB, GB).
- `ls -t`: Sort by modification time (newest first).
- **mkdir**: Create directory.
```bash
mkdir new_directory
```
- **rmdir**: Remove directory (empty).
```bash
rmdir empty_directory
```
- **touch**: Create an empty file or update the timestamp of an existing file.
```bash
touch new_file.txt
```
- **rm**: Remove file or directory.
- `rm file.txt`: Remove a file.
- `rm -r directory`: Remove a directory and its contents recursively (use with caution!).
- `rm -f file.txt`: Force remove a file, even if you don't have write permissions.
- **cp**: Copy file or directory.
```bash
cp file.txt new_location.txt
cp -r directory new_directory
```
- **mv**: Move or rename file or directory.
```bash
mv file.txt new_name.txt
mv file.txt /new/location/
```
- **cat**: Concatenate and display file contents.
```bash
cat file.txt
```
- **less**: View file contents page by page. Press q to quit.
```bash
less large_file.txt
```
- **head**: Display the first few lines of a file (default: 10 lines).
```bash
head file.txt
head -n 20 file.txt # Display the first 20 lines
```
- **tail**: Display the last few lines of a file (default: 10 lines). Useful for monitoring log files.
```bash
tail file.txt
tail -f log_file.txt # Follow the log file in real-time
```
- **echo**: Display text.
```bash
echo "Hello, world!"
echo $PATH # Display the value of the PATH environment variable
```
- **man**: Display the manual page for a command.
```bash
man ls
```
- **history**: Show the command history.
- `!n`: Execute the nth command in the history.
- `!!`: Execute the last command.
- `Ctrl+r`: Reverse search the command history.
### File Permissions {#file-permissions}
Linux file permissions control who can access and modify files and directories. Permissions are represented by three sets of three characters: rwx for the owner, group, and others.
- **r**: Read permission.
- **w**: Write permission.
- **x**: Execute permission (for files) or enter/search permission (for directories).
Use `ls -l` to view permissions. For example: `-rwxr-xr-- 1 user group file.txt`
The first character indicates the file type: `-` (regular file), `d` (directory), `l` (symbolic link), etc.
- The next three characters (rwx) are the owner's permissions.
- The next three characters (r-x) are the group's permissions.
- The last three characters (r--) are the permissions for others.
Use `chmod` to change permissions.
**Symbolic mode:**
- `chmod u+x file.txt`: Add execute permission for the owner.
- `chmod g-w file.txt`: Remove write permission for the group.
- `chmod o=r file.txt`: Set read-only permission for others.
**Numeric mode:** Permissions are represented by octal numbers. 4 for read, 2 for write, 1 for execute. Add the numbers together to get the permission value.
- `7 (rwx)`: 4 + 2 + 1
- `6 (rw-)`: 4 + 2 + 0
- `5 (r-x)`: 4 + 0 + 1
- `4 (r--)`: 4 + 0 + 0
- `chmod 755 file.txt`: Set rwx for the owner, r-x for the group, and r-x for others.
- `chmod 644 file.txt`: Set rw- for the owner, r-- for the group, and r-- for others.
Use `chown` to change the owner and group of a file.
```bash
sudo chown user:group file.txt
```
## Package Management {#package-management}
Package managers are essential for installing, updating, and removing software.
### Debian/Ubuntu (APT): {#debian/ubuntu-(apt):}
- `sudo apt update`: Update the package list.
- `sudo apt upgrade`: Upgrade installed packages.
- `sudo apt install package_name`: Install a package.
- `sudo apt remove package_name`: Remove a package.
- `sudo apt purge package_name`: Remove a package and its configuration files.
- `apt search keyword`: Search for packages.
### Fedora/CentOS/RHEL (DNF/YUM): {#fedora/centos/rhel-(dnf/yum):}
- `sudo dnf update`: Update the package list and upgrade installed packages.
- `sudo dnf install package_name`: Install a package.
- `sudo dnf remove package_name`: Remove a package.
- `dnf search keyword`: Search for packages.
### Arch Linux (Pacman): {#arch-linux-(pacman):}
- `sudo pacman -Syu`: Synchronize package databases and upgrade installed packages.
- `sudo pacman -S package_name`: Install a package.
- `sudo pacman -R package_name`: Remove a package.
- `pacman -Ss keyword`: Search for packages.
## Redirection and Piping {#redirection-and-piping}
Redirection allows you to redirect the input and output of commands. Piping allows you to chain commands together.
- **>**: Redirect output to a file (overwrites the file).
```bash
ls -l > file_list.txt
```
- **>>**: Redirect output to a file (appends to the file).
```bash
echo "New entry" >> file_list.txt
```
- **<**: Redirect input from a file.
```bash
mail -s "Subject" user@example.com < message.txt
```
- **|**: Pipe the output of one command to the input of another.
```bash
ls -l | grep "file.txt" # List files and filter for "file.txt"
cat file.txt | less # View a large file page by page
```
## Text Processing Tools {#text-processing-tools}
- **grep**: Search for patterns in files.
- `grep "pattern" file.txt`: Search for "pattern" in "file.txt".
- `grep -i "pattern" file.txt`: Case-insensitive search.
- `grep -r "pattern" directory`: Recursive search in a directory.
- **sed**: Stream editor for text manipulation.
- `sed 's/old/new/g' file.txt`: Replace all occurrences of "old" with "new" in "file.txt".
- `sed -i 's/old/new/g' file.txt`: Replace in-place (modifies the original file).
- **awk**: Pattern scanning and processing language.
- `awk '{print $1}' file.txt`: Print the first field of each line in "file.txt" (fields are separated by whitespace by default).
- `awk -F',' '{print $2}' file.csv`: Print the second field of each line in "file.csv" (fields are separated by commas).
## Networking Commands {#networking-commands}
- **ping**: Test network connectivity.
```bash
ping google.com
```
- **ifconfig** or **ip addr**: Display network interface information. `ip addr` is the modern replacement for `ifconfig`.
```bash
ip addr
```
- **netstat** or **ss**: Display network connections, routing tables, and interface statistics. `ss` is the modern replacement for `netstat`.
```bash
ss -tulnp
```
- **ssh**: Secure Shell for remote access.
```bash
ssh user@remote_host
```
- **scp**: Secure copy for transferring files.
```bash
scp file.txt user@remote_host:/path/to/destination/
```
- **wget**: Download files from the web.
```bash
wget https://example.com/file.txt
```
- **curl**: Transfer data from or to a server.
```bash
curl https://example.com
```
- **traceroute**: Trace the route packets take to a host.
```bash
traceroute google.com
```
- **nslookup**: Query DNS servers.
```bash
nslookup google.com
```
## Process Management {#process-management}
- **ps**: Display running processes.
- `ps aux`: Display all processes with detailed information.
- `ps -ef`: Display all processes with full command lines.
- **top**: Display a dynamic real-time view of running processes.
- **htop**: An interactive process viewer (needs to be installed).
- **kill**: Terminate a process.
```bash
kill process_id
kill -9 process_id # Forcefully kill a process
```
- **pkill**: Kill processes by name.
```bash
pkill process_name
```
- **nice**: Run a process with a modified priority.
```bash
nice -n 10 command # Run command with a lower priority
```
- **renice**: Change the priority of a running process.
```bash
renice -n 10 process_id
```
- **bg**: Move a process to the background.
- **fg**: Move a process to the foreground.
- **jobs**: List background jobs.
## System Information {#system-information}
- **uname -a**: Display kernel information.
- **hostname**: Display the hostname.
- **uptime**: Display how long the system has been running.
- **free -m**: Display memory usage in megabytes.
- **df -h**: Display disk space usage in human-readable format.
- **du -hsx * | sort -rh | head -10**: List the top 10 largest directories in the current directory.
- **lscpu**: Display CPU information.
- **lspci**: Display PCI device information.
- **lsusb**: Display USB device information.
## Shell Scripting {#shell-scripting}
Shell scripting allows you to automate tasks by writing scripts that execute a series of commands.
### Basic Script Structure {#basic-script-structure}
1. **Create a Script**: Create a file with a.sh extension (e.g., `my_script.sh`).
2. **Shebang**: Start the script with a shebang line to specify the interpreter (usually `#!/bin/bash`).
3. **Commands**: Add commands to the script.
4. **Make Executable**: Use `chmod +x my_script.sh` to make the script executable.
5. **Run the Script**: Execute the script using `./my_script.sh`.
### Example Script {#example-script}
```bash
#!/bin/bash {#binbash}
# This is a comment {#this-is-a-comment}
echo "Hello, world!"
# Create a directory {#create-a-directory}
mkdir my_directory
# List the contents of the directory {#list-the-contents-of-the-directory}
ls -l my_directory
```
### Variables {#variables}
```bash
NAME="John Doe"
echo "Hello, $NAME"
```
### Conditional Statements {#conditional-statements}
```bash
if [ $NAME == "John Doe" ]; then
echo "Name is John Doe"
else
echo "Name is not John Doe"
fi
```
### Loops {#loops}
```bash
for i in 1 2 3 4 5; do
echo "Number: $i"
done
```
### Functions {#functions}
```bash
my_function() {
echo "This is a function"
}
my_function
```
## System Administration {#system-administration}
### User and Group Management {#user-and-group-management}
- **useradd**: Create a new user.
```bash
sudo useradd newuser
sudo passwd newuser # Set the password for the new user
```
- **userdel**: Delete a user.
```bash
sudo userdel -r newuser # -r removes the home directory
```
- **usermod**: Modify a user account.
```bash
sudo usermod -aG sudo newuser # Add newuser to the sudo group
```
- **groupadd**: Create a new group.
```bash
sudo groupadd newgroup
```
- **groupdel**: Delete a group.
```bash
sudo groupdel newgroup
```
- **gpasswd**: Administer groups.
```bash
sudo gpasswd -a user group # Add user to group
sudo gpasswd -d user group # Remove user from group
```
- **id**: Display user and group information.
### Service Management {#service-management}
Systemd is the system and service manager in most modern Linux distributions.
- `systemctl start service_name`: Start a service.
- `systemctl stop service_name`: Stop a service.
- `systemctl restart service_name`: Restart a service.
- `systemctl status service_name`: Check the status of a service.
- `systemctl enable service_name`: Enable a service to start at boot.
- `systemctl disable service_name`: Disable a service from starting at boot.
- `systemctl is-enabled service_name`: Check if a service is enabled.
- `journalctl -u service_name`: View the logs for a service.
### Log Management {#log-management}
Linux systems generate logs that are crucial for troubleshooting and security auditing.
**Log Files and Tools:**
- `/var/log`: The main directory for log files
- `journalctl`: Query the systemd journal (centralized logging system)
**Common journalctl Commands:**
- `journalctl -xe`: View logs with explanations and extra context
- `journalctl -f`: Follow the logs in real-time
- `journalctl -b`: View logs from the current boot
- `journalctl --since "yesterday"`: View logs from yesterday
- `journalctl --until "today"`: View logs until today
**Additional Tools:**
- `dmesg`: Display kernel messages (useful for hardware issues)
- `logrotate`: A utility for managing log files (rotating, compressing, and deleting old logs)
- Configuration files are typically located in `/etc/logrotate.d/`
### Task Scheduling (Cron) {#task-scheduling-(cron)}
Cron allows you to schedule tasks to run automatically at specific times.
**Basic Crontab Commands:**
- `crontab -e`: Edit the crontab file
- `crontab -l`: List the crontab entries
- `crontab -r`: Remove the crontab
**Crontab Syntax:**
```
minute hour day_of_month month day_of_week command
```
**Common Examples:**
- `0 0 * * * /path/to/script.sh`: Run the script every day at midnight
- `0 12 * * 1 /path/to/script.sh`: Run the script every Monday at noon
- `*/5 * * * * /path/to/script.sh`: Run the script every 5 minutes
### Backup and Restore {#backup-and-restore}
Regular backups are crucial for data protection.
#### tar (Tape Archive) {#tar-(tape-archive)}
- A common tool for archiving files:
```bash
# Create a tar archive {#create-a-tar-archive}
tar -cvf backup.tar /path/to/directory
# Extract a tar archive {#extract-a-tar-archive}
tar -xvf backup.tar
# Create a compressed tar archive (gzip) {#create-a-compressed-tar-archive-gzip}
tar -czvf backup.tar.gz /path/to/directory
# Extract a compressed tar archive (gzip) {#extract-a-compressed-tar-archive-gzip}
tar -xzvf backup.tar.gz
# Create a compressed tar archive (bzip2) {#create-a-compressed-tar-archive-bzip2}
tar -cjvf backup.tar.bz2 /path/to/directory
# Extract a compressed tar archive (bzip2) {#extract-a-compressed-tar-archive-bzip2}
tar -xjvf backup.tar.bz2
```
#### rsync (Remote Sync) {#rsync-(remote-sync)}
- A powerful tool for synchronizing files and directories:
```bash
# Local sync {#local-sync}
rsync -av /path/to/source/ /path/to/destination/
# Remote sync {#remote-sync}
rsync -av user@remote_host:/path/to/source/ /path/to/destination/
Options:
-a: archive mode (preserves permissions, timestamps, etc.)
-v: verbose
-z: compress data during transfer
-r: recursive
```
### Performance Monitoring {#performance-monitoring}
#### System Resource Monitoring {#system-resource-monitoring}
- **top/htop**: Real-time process monitoring
- **vmstat**: Virtual memory statistics
- **iostat**: I/O statistics
- **sar**: System activity reporter (collects and reports system activity data)
- **free -m**: Memory usage
- **df -h**: Disk space usage
- **iotop**: I/O monitoring (needs to be installed)
### Security {#security}
#### User Authentication {#user-authentication}
- **Password Policies**: Enforce strong password requirements
Multi-factor authentication (MFA): Implement MFA for enhanced security. Tools like Google Authenticator or Authy can be used with PAM (Pluggable Authentication Modules).
#### SSH Authentication {#ssh-authentication}
- Disable password-based SSH authentication and use SSH keys instead
- Steps:
```bash
# Generate SSH key pair on client machine {#generate-ssh-key-pair-on-client-machine}
ssh-keygen -t rsa -b 4096
# Copy public key to server {#copy-public-key-to-server}
ssh-copy-id user@remote_host
# Disable password authentication on server {#disable-password-authentication-on-server}
# Edit /etc/ssh/sshd_config: {#edit-etcsshsshd_config}
# PasswordAuthentication no {#passwordauthentication-no}
# Restart SSH service {#restart-ssh-service}
sudo systemctl restart sshd
```
#### Firewall Configuration {#firewall-configuration}
- Firewalls control network traffic in and out of the system
##### iptables (Traditional Firewall) {#iptables-(traditional-firewall)}
```bash
# List current rules {#list-current-rules}
iptables -L
# Allow SSH traffic {#allow-ssh-traffic}
iptables -A INPUT -p tcp --dport 22 -j ACCEPT
# Block HTTP traffic {#block-http-traffic}
iptables -A INPUT -p tcp --dport 80 -j DROP
```
##### nftables (Modern Firewall) {#nftables-(modern-firewall)}
```bash
# List current rules {#list-current-rules}
nft list ruleset
# Allow SSH traffic {#allow-ssh-traffic}
nft add rule inet filter input tcp dport 22 accept
# Block HTTP traffic {#block-http-traffic}
nft add rule inet filter input tcp dport 80 drop
```
##### UFW (Uncomplicated Firewall) {#ufw-(uncomplicated-firewall)}
Common in Ubuntu/Debian systems:
```bash
# Enable and check firewall {#enable-and-check-firewall}
ufw enable
ufw status
# Configure rules {#configure-rules}
ufw allow 22/tcp # Allow SSH traffic
ufw deny 80/tcp # Block HTTP traffic
```
Intrusion Detection Systems (IDS)
IDS monitor network traffic and system activity for malicious behavior.
##### Network-based IDS {#network-based-ids}
- **Snort**: A popular network IDS
```bash
# Install Snort {#install-snort}
sudo apt install snort
# Check Snort configuration {#check-snort-configuration}
sudo snort -T -c /etc/snort/snort.conf
```
##### Host-based IDS {#host-based-ids}
- **Tripwire**: File integrity monitoring
```bash
# Initialize database {#initialize-database}
sudo tripwire --init
# Check for changes {#check-for-changes}
sudo tripwire --check
```
- **AIDE** (Advanced Intrusion Detection Environment)
```bash
# Install AIDE {#install-aide}
sudo apt install aide
# Initialize database {#initialize-database}
sudo aideinit
# Check for changes {#check-for-changes}
sudo aide --check
```
#### Security Auditing {#security-auditing}
Regularly audit system logs and system activity for security monitoring.
##### System Logs {#system-logs}
- **Authentication Logs**: `/var/log/auth.log` or `/var/log/secure`
- **System Logs**: `/var/log/syslog` or `/var/log/messages`
- **Kernel Logs**: `/var/log/kern.log`
##### User Activity Monitoring {#user-activity-monitoring}
```bash
# Show last logged in users {#show-last-logged-in-users}
last
# Show current user sessions and activity {#show-current-user-sessions-and-activity}
w
# Show logged in users {#show-logged-in-users}
who
```
##### Network Activity Monitoring {#network-activity-monitoring}
```bash
# Show listening ports (traditional) {#show-listening-ports-traditional}
netstat -tuln
# Show listening ports (modern) {#show-listening-ports-modern}
ss -tuln
# List open network files {#list-open-network-files}
lsof -i
```
Rootkit Detection
Rootkits are malicious software that hide their presence and grant unauthorized access.
#### Rootkit Detection {#rootkit-detection}
Rootkits are malicious software that hide their presence and grant unauthorized access.
##### Detection Tools {#detection-tools}
- **rkhunter** (Rootkit Hunter)
```bash
# Install rkhunter {#install-rkhunter}
sudo apt install rkhunter
# Update the database {#update-the-database}
sudo rkhunter --update
# Perform a system check {#perform-a-system-check}
sudo rkhunter --check
```
- **chkrootkit**
```bash
# Install chkrootkit {#install-chkrootkit}
sudo apt install chkrootkit
# Run system scan {#run-system-scan}
sudo chkrootkit
```
##### Best Practices {#best-practices}
- Run rootkit scans regularly as part of security maintenance
- Keep detection tools updated
- Investigate any suspicious findings immediately
- Maintain system backups in case of compromise
#### SELinux/AppArmor {#selinux/apparmor}
These are Mandatory Access Control (MAC) systems that provide an extra layer of security by defining policies that restrict what processes can do.
#### SELinux/AppArmor {#selinux/apparmor}
Mandatory Access Control (MAC) systems that provide an extra layer of security by defining policies that restrict what processes can do.
##### SELinux Management {#selinux-management}
```bash
# Check SELinux status {#check-selinux-status}
getenforce
# Set SELinux mode (0=permissive, 1=enforcing) {#set-selinux-mode-0permissive-1enforcing}
setenforce 1
# Set SELinux boolean values {#set-selinux-boolean-values}
setsebool -P httpd_can_network_connect on
```
##### AppArmor Management {#apparmor-management}
```bash
# Check AppArmor status {#check-apparmor-status}
aa-status
# Set a profile to enforce mode {#set-a-profile-to-enforce-mode}
aa-enforce /etc/apparmor.d/profile_name
# Set a profile to complain mode {#set-a-profile-to-complain-mode}
aa-complain /etc/apparmor.d/profile_name
```
##### Best Practices {#best-practices}
- Always test policy changes in permissive mode first
- Monitor system logs for policy violations
- Keep policies updated with system changes
- Document custom policy modifications
Virtualization
Virtualization allows you to run multiple operating systems on a single physical machine.
#### Virtualization {#virtualization}
Virtualization allows you to run multiple operating systems on a single physical machine.
##### Virtualization Platforms {#virtualization-platforms}
- **VirtualBox**
- Open-source virtualization platform
- User-friendly interface
- Supports most operating systems
- **KVM** (Kernel-based Virtual Machine)
```bash
# Install KVM and required packages {#install-kvm-and-required-packages}
sudo apt install qemu-kvm libvirt-daemon-system
# Add user to required groups {#add-user-to-required-groups}
sudo usermod -aG libvirt $USER
sudo usermod -aG kvm $USER
# Launch virtual machine manager {#launch-virtual-machine-manager}
virt-manager
```
- **VMware**
- Commercial virtualization platform
- Enterprise-grade features
- Professional support available
##### Container Virtualization {#container-virtualization}
- **Docker**
```bash
# Pull an image {#pull-an-image}
docker pull ubuntu:latest
# Run a container {#run-a-container}
docker run -it ubuntu:latest
# List running containers {#list-running-containers}
docker ps
```
##### Best Practices {#best-practices}
- Regular backups of virtual machines
- Monitor resource usage
- Keep virtualization software updated
- Use snapshots before major changes
### Advanced Topics {#advanced-topics}
#### Kernel Compilation {#kernel-compilation}
Compiling the Linux kernel allows you to customize the kernel to your specific hardware and software needs.
```bash
# Download and extract kernel source {#download-and-extract-kernel-source}
wget https://cdn.kernel.org/pub/linux/kernel/v5.x/linux-5.x.tar.xz
tar xf linux-5.x.tar.xz
cd linux-5.x
# Configure kernel {#configure-kernel}
make menuconfig
# Compile kernel {#compile-kernel}
make -j$(nproc)
# Install modules and kernel {#install-modules-and-kernel}
sudo make modules_install
sudo make install
```
#### LVM (Logical Volume Management) {#lvm-(logical-volume-management)}
LVM allows you to manage disk space flexibly.
```bash
# Create physical volume {#create-physical-volume}
pvcreate /dev/sda1
# Create volume group {#create-volume-group}
vgcreate myvg /dev/sda1
# Create and format logical volume {#create-and-format-logical-volume}
lvcreate -L 10G -n mylv myvg
mkfs.ext4 /dev/myvg/mylv
# Mount logical volume {#mount-logical-volume}
mount /dev/myvg/mylv /mnt
# Resize logical volume {#resize-logical-volume}
lvresize -L +5G /dev/myvg/mylv
resize2fs /dev/myvg/mylv
```
#### System Tuning {#system-tuning}
##### Kernel Parameter Management {#kernel-parameter-management}
```bash
# List all kernel parameters {#list-all-kernel-parameters}
sysctl -a
# Set a kernel parameter {#set-a-kernel-parameter}
sysctl -w vm.swappiness=60
# Make changes persistent {#make-changes-persistent}
echo "vm.swappiness=60" >> /etc/sysctl.conf
sysctl -p
```
##### Process Priority Management {#process-priority-management}
```bash
# Start a process with lower priority {#start-a-process-with-lower-priority}
nice -n 10 command
# Change priority of running process {#change-priority-of-running-process}
renice -n 10 -p process_id
# Set resource limits {#set-resource-limits}
ulimit -n 4096 # Set maximum number of open files
```
##### System Optimization {#system-optimization}
- **tuned**: Daemon for system tuning
```bash
# Install tuned {#install-tuned}
sudo apt install tuned
# List available profiles {#list-available-profiles}
tuned-adm list
# Apply a profile {#apply-a-profile}
tuned-adm profile balanced
```
#### System Profiling {#system-profiling}
##### Performance Monitoring {#performance-monitoring}
- **top/htop**: Real-time system monitoring
- **sar**: System activity reporter
- **iotop**: I/O monitoring
##### Advanced Analysis Tools {#advanced-analysis-tools}
```bash
# Trace system calls {#trace-system-calls}
strace command
# Profile CPU performance {#profile-cpu-performance}
perf record command
perf report
# Trace kernel functions {#trace-kernel-functions}
ftrace
```
##### Best Practices {#best-practices}
- Regular performance monitoring
- Baseline performance metrics
- Document system changes
- Test changes in staging environment